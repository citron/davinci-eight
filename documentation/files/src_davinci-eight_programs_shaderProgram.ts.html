<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/programs/shaderProgram.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.72.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribLocation..html">AttribLocation.</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/RenderingContextUser.html">RenderingContextUser</a></li>
                                <li><a href="../classes/ShaderProgram.html">ShaderProgram</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/programs/shaderProgram.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import AttribDataInfo = require(&#x27;../core/AttribDataInfo&#x27;);
import AttribDataInfos = require(&#x27;../core/AttribDataInfos&#x27;);
import AttribProvider = require(&#x27;../core/AttribProvider&#x27;);
import ShaderProgram = require(&#x27;../core/ShaderProgram&#x27;);
import parse = require(&#x27;../glsl/parse&#x27;);
import Matrix1 = require(&#x27;../math/Matrix1&#x27;);
import Matrix2 = require(&#x27;../math/Matrix2&#x27;);
import Matrix3 = require(&#x27;../math/Matrix3&#x27;);
import Matrix4 = require(&#x27;../math/Matrix4&#x27;);
import NodeWalker = require(&#x27;../glsl/NodeWalker&#x27;);
import ProgramArgs = require(&#x27;../glsl/ProgramArgs&#x27;);
import Declaration = require(&#x27;../glsl/Declaration&#x27;);
import DebugNodeEventHandler = require(&#x27;../glsl/DebugNodeEventHandler&#x27;);
import DefaultNodeEventHandler = require(&#x27;../glsl/DefaultNodeEventHandler&#x27;);
import expectArg = require(&#x27;../checks/expectArg&#x27;);
import isDefined = require(&#x27;../checks/isDefined&#x27;);
import uuid4 = require(&#x27;../utils/uuid4&#x27;);
import AttribLocation = require(&#x27;../core/AttribLocation&#x27;);
import UniformLocation = require(&#x27;../core/UniformLocation&#x27;);
import UniformMetaInfo = require(&#x27;../core/UniformMetaInfo&#x27;);
import UniformMetaInfos = require(&#x27;../core/UniformMetaInfos&#x27;);
import Vector1 = require(&#x27;../math/Vector1&#x27;);
import Vector2 = require(&#x27;../math/Vector2&#x27;);
import Vector3 = require(&#x27;../math/Vector3&#x27;);
import Vector4 = require(&#x27;../math/Vector4&#x27;);

var shaderProgram = function(vertexShader: string, fragmentShader: string, uuid: string = uuid4().generate()): ShaderProgram {

  if (typeof vertexShader !== &#x27;string&#x27;) {
    throw new Error(&quot;vertexShader argument must be a string.&quot;);
  }

  if (typeof fragmentShader !== &#x27;string&#x27;) {
    throw new Error(&quot;fragmentShader argument must be a string.&quot;);
  }

  var refCount: number = 0;
  var program: WebGLProgram;
  var $context: WebGLRenderingContext;

  var attributeLocations: { [name: string]: AttribLocation } = {};
  var uniformLocations: { [name: string]: UniformLocation } = {};

  var self: ShaderProgram = {
    get vertexShader() {
      return vertexShader;
    },
    get fragmentShader() {
      return fragmentShader;
    },
    get attributes(): { [name: string]: AttribLocation } {
      return attributeLocations;
    },
    get uniforms(): { [name: string]: UniformLocation } {
      return uniformLocations;
    },
    addRef(): void {
      refCount++;
      // console.log(&quot;shaderProgram.addRef() =&gt; &quot; + refCount);
    },
    release(): void {
      refCount--;
      // console.log(&quot;shaderProgram.release() =&gt; &quot; + refCount);
      if (refCount === 0) {
        self.contextFree();
      }
    },
    contextFree() {
      if (isDefined($context)) {
        if (program) {
          // console.log(&quot;WebGLProgram deleted&quot;);
          $context.deleteProgram(program);
          program = void 0;
        }
        $context = void 0;
        for(var aName in attributeLocations) {
          attributeLocations[aName].contextFree();
        }
        for(var uName in uniformLocations) {
          uniformLocations[uName].contextFree();
        }
      }
    },
    contextGain(context: WebGLRenderingContext): void {
      if ($context !== context) {
        self.contextFree();
        $context = context;
        program = makeWebGLProgram(context, vertexShader, fragmentShader);

        let activeAttributes: number = context.getProgramParameter(program, context.ACTIVE_ATTRIBUTES);
        for (var a = 0; a &lt; activeAttributes; a++) {
          let activeInfo: WebGLActiveInfo = context.getActiveAttrib(program, a);
          let name: string = activeInfo.name;
          // The following properties don&#x27;t correspond directly wuth those used.
          // If the attribute or uniform is an array, this will be the number of elements in the array. Otherwise, this will be 1.
          let size: number = activeInfo.size;
          let type: number = activeInfo.type;
          if (!attributeLocations[name]) {
            // TODO: Since name MUST be part of Location, maybe should use an array?
            attributeLocations[name] = new AttribLocation(name, activeInfo.size, activeInfo.type);
          }
        }
        let activeUniforms: number = context.getProgramParameter(program, context.ACTIVE_UNIFORMS);
        for (var u = 0; u &lt; activeUniforms; u++) {
          let activeInfo: WebGLActiveInfo = context.getActiveUniform(program, u);
          let name: string = activeInfo.name;
          if (!uniformLocations[name]) {
            // TODO: Since name MUST be part of Location, maybe should use an array?
            // TODO: Seems like we should be able to make use of the size and type?
            uniformLocations[name] = new UniformLocation(name);
          }
        }
        for(var aName in attributeLocations) {
          attributeLocations[aName].contextGain(context, program);
        }
        for(var uName in uniformLocations) {
          uniformLocations[uName].contextGain(context, program);
        }
      }
    },
    contextLoss() {
      program = void 0;
      $context = void 0;
      for(var aName in attributeLocations) {
        attributeLocations[aName].contextLoss();
      }
      for(var uName in uniformLocations) {
        uniformLocations[uName].contextLoss();
      }
    },
    hasContext: function(): boolean {
      return !!$context;
    },
    get program() { return program; },
    get programId() {return uuid;},
    use(): ShaderProgram {
      if ($context) {
        $context.useProgram(program);
      }
      else {
        console.warn(&quot;shaderProgram.use() missing WebGLRenderingContext&quot;);
      }
      return self;
    },
    enableAttrib(name: string) {
      let attribLoc = attributeLocations[name];
      if (attribLoc) {
        attribLoc.enable();
      }
    },
    setAttributes(values: AttribDataInfos) {
      for (var name in attributeLocations) {
        let attribLoc = attributeLocations[name];
        let data: AttribDataInfo = values[name];
        if (data) {
          data.buffer.bind();
          attribLoc.vertexPointer(data.numComponents, data.normalized, data.stride, data.offset);
        }
        else {
          throw new Error(&quot;The mesh does not support the attribute variable named &quot; + name);
        }
      }
    },
    uniform1f(name: string, x: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform1f(x);
      }
    },
    uniform2f(name: string, x: number, y: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform2f(x, y);
      }
    },
    uniform3f(name: string, x: number, y: number, z: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform3f(x, y, z);
      }
    },
    uniform4f(name: string, x: number, y: number, z: number, w: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform4f(x, y, z, w);
      }
    },
    uniformMatrix1(name: string, transpose: boolean, matrix: Matrix1) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix1(transpose, matrix);
      }
    },
    uniformMatrix2(name: string, transpose: boolean, matrix: Matrix2) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix2(transpose, matrix);
      }
    },
    uniformMatrix3(name: string, transpose: boolean, matrix: Matrix3) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix3(transpose, matrix);
      }
    },
    uniformMatrix4(name: string, transpose: boolean, matrix: Matrix4) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix4(transpose, matrix);
      }
    },
    uniformVector1(name: string, vector: Vector1) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector1(vector);
      }
    },
    uniformVector2(name: string, vector: Vector2) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector2(vector);
      }
    },
    uniformVector3(name: string, vector: Vector3) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector3(vector);
      }
    },
    uniformVector4(name: string, vector: Vector4) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector4(vector);
      }
    }
  };
  return self;
};

function makeWebGLShader(gl: WebGLRenderingContext, source: string, type: number): WebGLShader {
  var shader: WebGLShader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader;
  }
  else {
    let message = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error(&quot;Error compiling shader: &quot; + message);
  }
}

/**
 * Creates a WebGLProgram with compiled and linked shaders.
 */
function makeWebGLProgram(gl: WebGLRenderingContext, vertexShader: string, fragmentShader: string): WebGLProgram {
  let vs: WebGLShader = makeWebGLShader(gl, vertexShader, gl.VERTEX_SHADER);
  let fs: WebGLShader = makeWebGLShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
  let program = gl.createProgram();
  // console.log(&quot;WebGLProgram created&quot;);
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
    return program;
  }
  else {
    let message: string = gl.getProgramInfoLog(program);

    gl.detachShader(program, vs);
    gl.deleteShader(vs);

    gl.detachShader(program, fs);
    gl.deleteShader(fs);

    gl.deleteProgram(program);
    // console.log(&quot;WebGLProgram deleted&quot;);

    throw new Error(&quot;Error linking program: &quot; + message);
  }
}

export = shaderProgram;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
