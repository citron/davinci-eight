<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/programs/shaderProgram.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.93.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribLocation..html">AttribLocation.</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/ContextListener.html">ContextListener</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Geometry3.html">Geometry3</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Matrix&lt;M&gt;.html">Matrix&lt;M&gt;</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/Program.html">Program</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Simplex.html">Simplex</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/programs/shaderProgram.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import AttribDataInfo = require(&#x27;../core/AttribDataInfo&#x27;);
import AttribDataInfos = require(&#x27;../core/AttribDataInfos&#x27;);
import AttribProvider = require(&#x27;../core/AttribProvider&#x27;);
import Program = require(&#x27;../core/Program&#x27;);
import Matrix1 = require(&#x27;../math/Matrix1&#x27;);
import Matrix2 = require(&#x27;../math/Matrix2&#x27;);
import Matrix3 = require(&#x27;../math/Matrix3&#x27;);
import Matrix4 = require(&#x27;../math/Matrix4&#x27;);
import expectArg = require(&#x27;../checks/expectArg&#x27;);
import uuid4 = require(&#x27;../utils/uuid4&#x27;);
import AttribLocation = require(&#x27;../core/AttribLocation&#x27;);
import UniformLocation = require(&#x27;../core/UniformLocation&#x27;);
import UniformMetaInfo = require(&#x27;../core/UniformMetaInfo&#x27;);
import UniformMetaInfos = require(&#x27;../core/UniformMetaInfos&#x27;);
import Vector1 = require(&#x27;../math/Vector1&#x27;);
import Vector2 = require(&#x27;../math/Vector2&#x27;);
import Vector3 = require(&#x27;../math/Vector3&#x27;);
import Vector4 = require(&#x27;../math/Vector4&#x27;);
import ContextManager = require(&#x27;../core/ContextManager&#x27;);
import refChange = require(&#x27;../utils/refChange&#x27;);

/**
 * Name used for reference count monitoring and logging.
 */
let LOGGING_NAME_SHAFER_PROGRAM = &#x27;Program&#x27;;

function makeWebGLShader(ctx: WebGLRenderingContext, source: string, type: number): WebGLShader {
  var shader: WebGLShader = ctx.createShader(type);
  ctx.shaderSource(shader, source);
  ctx.compileShader(shader);
  let compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
  if (compiled) {
    return shader;
  }
  else {
    if (!ctx.isContextLost()) {
      let message = ctx.getShaderInfoLog(shader);
      ctx.deleteShader(shader);
      throw new Error(&quot;Error compiling shader: &quot; + message);
    }
    else {
      throw new Error(&quot;Context lost while compiling shader&quot;);
    }
  }
}

/**
 * Creates a WebGLProgram with compiled and linked shaders.
 */
function makeWebGLProgram(ctx: WebGLRenderingContext, vertexShader: string, fragmentShader: string, attribs: string[]): WebGLProgram {
  // create our shaders
  let vs: WebGLShader = makeWebGLShader(ctx, vertexShader, ctx.VERTEX_SHADER);
  let fs: WebGLShader = makeWebGLShader(ctx, fragmentShader, ctx.FRAGMENT_SHADER);

  // Create the program object.
  let program = ctx.createProgram();
  // console.log(&quot;WebGLProgram created&quot;);

  // Attach our two shaders to the program.
  ctx.attachShader(program, vs);
  ctx.attachShader(program, fs);

  // Bind attributes allows us to specify the index that an attribute should be bound to.
  for (var index = 0; index &lt; attribs.length; ++index) {
    ctx.bindAttribLocation(program, index, attribs[index]);
  }

  // Link the program.
  ctx.linkProgram(program);

  // Check the link status
  let linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
  if (linked || ctx.isContextLost()) {
    return program;
  }
  else {
    let message: string = ctx.getProgramInfoLog(program);

    ctx.detachShader(program, vs);
    ctx.deleteShader(vs);

    ctx.detachShader(program, fs);
    ctx.deleteShader(fs);

    ctx.deleteProgram(program);

    throw new Error(&quot;Error linking program: &quot; + message);
  }
}

let shaderProgram = function(monitor: ContextManager, vertexShader: string, fragmentShader: string, attribs: string[]): Program {

  if (typeof vertexShader !== &#x27;string&#x27;) {
    throw new Error(&quot;vertexShader argument must be a string.&quot;);
  }

  if (typeof fragmentShader !== &#x27;string&#x27;) {
    throw new Error(&quot;fragmentShader argument must be a string.&quot;);
  }

  var refCount: number = 1;
  var program: WebGLProgram;
  var $context: WebGLRenderingContext;
  let uuid: string = uuid4().generate()
  var attributeLocations: { [name: string]: AttribLocation } = {};
  var uniformLocations: { [name: string]: UniformLocation } = {};

  var self: Program = {
    get vertexShader() {
      return vertexShader;
    },
    get fragmentShader() {
      return fragmentShader;
    },
    get attributes(): { [name: string]: AttribLocation } {
      return attributeLocations;
    },
    get uniforms(): { [name: string]: UniformLocation } {
      return uniformLocations;
    },
    addRef(): number {
      refChange(uuid, LOGGING_NAME_SHAFER_PROGRAM, +1);
      refCount++;
      return refCount;
    },
    release(): number {
      refChange(uuid, LOGGING_NAME_SHAFER_PROGRAM, -1);
      refCount--;
      if (refCount === 0) {
        monitor.removeContextListener(self);
        self.contextFree();
      }
      return refCount;
    },
    contextFree() {
      if ($context) {
        if (program) {
          $context.deleteProgram(program);
          program = void 0;
        }
        $context = void 0;
        for(var aName in attributeLocations) {
          attributeLocations[aName].contextFree();
        }
        for(var uName in uniformLocations) {
          uniformLocations[uName].contextFree();
        }
      }
    },
    contextGain(context: WebGLRenderingContext): void {
      if ($context !== context) {
        self.contextFree();
        $context = context;
        program = makeWebGLProgram(context, vertexShader, fragmentShader, attribs);

        let activeAttributes: number = context.getProgramParameter(program, context.ACTIVE_ATTRIBUTES);
        for (var a = 0; a &lt; activeAttributes; a++) {
          let activeAttribInfo: WebGLActiveInfo = context.getActiveAttrib(program, a);
          let name: string = activeAttribInfo.name;
          if (!attributeLocations[name]) {
            attributeLocations[name] = new AttribLocation(monitor, name);
          }
        }
        let activeUniforms: number = context.getProgramParameter(program, context.ACTIVE_UNIFORMS);
        for (var u = 0; u &lt; activeUniforms; u++) {
          let activeUniformInfo: WebGLActiveInfo = context.getActiveUniform(program, u);
          let name: string = activeUniformInfo.name;
          if (!uniformLocations[name]) {
            uniformLocations[name] = new UniformLocation(monitor, name);
          }
        }
        for(var aName in attributeLocations) {
          attributeLocations[aName].contextGain(context, program);
        }
        for(var uName in uniformLocations) {
          uniformLocations[uName].contextGain(context, program);
        }
      }
    },
    contextLoss() {
      program = void 0;
      $context = void 0;
      for(var aName in attributeLocations) {
        attributeLocations[aName].contextLoss();
      }
      for(var uName in uniformLocations) {
        uniformLocations[uName].contextLoss();
      }
    },
    get program() { return program; },
    get programId() {return uuid;},
    use(): Program {
      if ($context) {
        $context.useProgram(program);
      }
      else {
        console.warn(LOGGING_NAME_SHAFER_PROGRAM + &quot; use() missing WebGLRenderingContext&quot;);
      }
      return self;
    },
    enableAttrib(name: string) {
      let attribLoc = attributeLocations[name];
      if (attribLoc) {
        attribLoc.enable();
      }
    },
    setAttributes(values: AttribDataInfos) {
      for (var name in attributeLocations) {
        let attribLoc = attributeLocations[name];
        let data: AttribDataInfo = values[name];
        if (data) {
          data.buffer.bind();
          attribLoc.vertexPointer(data.size, data.normalized, data.stride, data.offset);
        }
        else {
          throw new Error(&quot;The mesh does not support the attribute variable named &quot; + name);
        }
      }
    },
    uniform1f(name: string, x: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform1f(x);
      }
    },
    uniform2f(name: string, x: number, y: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform2f(x, y);
      }
    },
    uniform3f(name: string, x: number, y: number, z: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform3f(x, y, z);
      }
    },
    uniform4f(name: string, x: number, y: number, z: number, w: number) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.uniform4f(x, y, z, w);
      }
    },
    uniformMatrix1(name: string, transpose: boolean, matrix: Matrix1) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix1(transpose, matrix);
      }
    },
    uniformMatrix2(name: string, transpose: boolean, matrix: Matrix2) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix2(transpose, matrix);
      }
    },
    uniformMatrix3(name: string, transpose: boolean, matrix: Matrix3) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix3(transpose, matrix);
      }
    },
    uniformMatrix4(name: string, transpose: boolean, matrix: Matrix4) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.matrix4(transpose, matrix);
      }
    },
    uniformVector1(name: string, vector: Vector1) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector1(vector);
      }
    },
    uniformVector2(name: string, vector: Vector2) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector2(vector);
      }
    },
    uniformVector3(name: string, vector: Vector3) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector3(vector);
      }
    },
    uniformVector4(name: string, vector: Vector4) {
      let uniformLoc = uniformLocations[name];
      if (uniformLoc) {
        uniformLoc.vector4(vector);
      }
    }
  };
  refChange(uuid, LOGGING_NAME_SHAFER_PROGRAM, +1);
  monitor.addContextListener(self);
  return self;
};

export = shaderProgram;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
