<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>amd/davinci-eight/glsl/expr.js - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/camera.html">camera</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: amd/davinci-eight/glsl/expr.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//
// See javascript.crockford.com/tdop/tdop.html
//
// We assume that the source text has been transformed into an array of tokens.
//
/// &lt;reference path=&#x27;./Symbol.d.ts&#x27;/&gt;
/// &lt;reference path=&#x27;./Token.d.ts&#x27;/&gt;
define([&quot;require&quot;, &quot;exports&quot;], function (require, exports) {
    var state;
    /**
     * The current token.
     */
    var token;
    var tokens;
    var idx;
    function fail(message) {
        return function () { return state.unexpected(message); };
    }
    /**
     * The prototype for all other symbols. Its method will usually be overridden.
     */
    var original_symbol = {
        nud: function () {
            return this.children &amp;&amp; this.children.length ? this : fail(&#x27;unexpected&#x27;)();
        },
        led: fail(&#x27;missing operator&#x27;)
    };
    var symbol_table = {};
    var itself = function () {
        return this;
    };
    /**
     * A function that makes symbols and looks them up in a cache.
     * @param id Identifier
     * @param bp Binding Power. Optional. Defaults to zero.
     */
    function symbol(id, bp) {
        var sym = symbol_table[id];
        bp = bp || 0;
        if (sym) {
            if (bp &gt; sym.lbp) {
                sym.lbp = bp;
            }
        }
        else {
            sym = Object.create(original_symbol);
            sym.id = id;
            sym.lbp = bp;
            symbol_table[id] = sym;
        }
        return sym;
    }
    function infix(id, bp, led) {
        var sym = symbol(id, bp);
        sym.led = led || function (left) {
            this.children = [left, expression(bp)];
            this.type = &#x27;binary&#x27;;
            return this;
        };
    }
    function infixr(id, bp, led) {
        var sym = symbol(id, bp);
        sym.led = led || function (left) {
            this.children = [left, expression(bp - 1)];
            this.type = &#x27;binary&#x27;;
            return this;
        };
        return sym;
    }
    function prefix(id, nud) {
        var sym = symbol(id);
        sym.nud = nud || function () {
            this.children = [expression(70)];
            this.type = &#x27;unary&#x27;;
            return this;
        };
        return sym;
    }
    function suffix(id) {
        var sym = symbol(id, 150);
        sym.led = function (left) {
            this.children = [left];
            this.type = &#x27;suffix&#x27;;
            return this;
        };
    }
    function assignment(id) {
        return infixr(id, 10, function (left) {
            this.children = [left, expression(9)];
            this.assignment = true;
            this.type = &#x27;assign&#x27;;
            return this;
        });
    }
    // parentheses included to avoid collisions with user-defined tokens.
    symbol(&#x27;(ident)&#x27;).nud = itself;
    symbol(&#x27;(keyword)&#x27;).nud = itself;
    symbol(&#x27;(builtin)&#x27;).nud = itself;
    symbol(&#x27;(literal)&#x27;).nud = itself;
    symbol(&#x27;(end)&#x27;); // Indicates the end of the token stream.
    symbol(&#x27;:&#x27;);
    symbol(&#x27;;&#x27;);
    symbol(&#x27;,&#x27;);
    symbol(&#x27;)&#x27;);
    symbol(&#x27;]&#x27;);
    symbol(&#x27;}&#x27;);
    infixr(&#x27;&amp;&amp;&#x27;, 30);
    infixr(&#x27;||&#x27;, 30);
    infix(&#x27;|&#x27;, 43);
    infix(&#x27;^&#x27;, 44);
    infix(&#x27;&amp;&#x27;, 45);
    infix(&#x27;==&#x27;, 46);
    infix(&#x27;!=&#x27;, 46);
    infix(&#x27;&lt;&#x27;, 47);
    infix(&#x27;&lt;=&#x27;, 47);
    infix(&#x27;&gt;&#x27;, 47);
    infix(&#x27;&gt;=&#x27;, 47);
    infix(&#x27;&gt;&gt;&#x27;, 48);
    infix(&#x27;&lt;&lt;&#x27;, 48);
    infix(&#x27;+&#x27;, 50);
    infix(&#x27;-&#x27;, 50);
    infix(&#x27;*&#x27;, 60);
    infix(&#x27;/&#x27;, 60);
    infix(&#x27;%&#x27;, 60);
    infix(&#x27;?&#x27;, 20, function (left) {
        this.children = [left, expression(0), (advance(&#x27;:&#x27;), expression(0))]; // original.
        //this.children = [];
        //this.children.push(left);
        //this.children.push(expression(0));
        //advance(&#x27;:&#x27;);
        //this.children.push(expression(0));
        this.type = &#x27;ternary&#x27;;
        return this;
    });
    infix(&#x27;.&#x27;, 80, function (left) {
        token.type = &#x27;literal&#x27;;
        state.fake(token);
        this.children = [left, token];
        advance();
        return this;
    });
    infix(&#x27;[&#x27;, 80, function (left) {
        this.children = [left, expression(0)];
        this.type = &#x27;binary&#x27;;
        advance(&#x27;]&#x27;);
        return this;
    });
    infix(&#x27;(&#x27;, 80, function (left) {
        this.children = [left];
        this.type = &#x27;call&#x27;;
        if (token.data !== &#x27;)&#x27;) {
            while (1) {
                this.children.push(expression(0));
                if (token.data !== &#x27;,&#x27;) {
                    break;
                }
                advance(&#x27;,&#x27;);
            }
        }
        advance(&#x27;)&#x27;);
        return this;
    });
    prefix(&#x27;-&#x27;);
    prefix(&#x27;+&#x27;);
    prefix(&#x27;!&#x27;);
    prefix(&#x27;~&#x27;);
    prefix(&#x27;defined&#x27;);
    prefix(&#x27;(&#x27;, function () {
        this.type = &#x27;group&#x27;;
        this.children = [expression(0)];
        advance(&#x27;)&#x27;);
        return this;
    });
    prefix(&#x27;++&#x27;);
    prefix(&#x27;--&#x27;);
    suffix(&#x27;++&#x27;);
    suffix(&#x27;--&#x27;);
    assignment(&#x27;=&#x27;);
    assignment(&#x27;+=&#x27;);
    assignment(&#x27;-=&#x27;);
    assignment(&#x27;*=&#x27;);
    assignment(&#x27;/=&#x27;);
    assignment(&#x27;%=&#x27;);
    assignment(&#x27;&amp;=&#x27;);
    assignment(&#x27;|=&#x27;);
    assignment(&#x27;^=&#x27;);
    assignment(&#x27;&gt;&gt;=&#x27;);
    assignment(&#x27;&lt;&lt;=&#x27;);
    function expr(incoming_state, incoming_tokens) {
        function emit(node) {
            state.unshift(node, false);
            for (var i = 0, len = node.children.length; i &lt; len; ++i) {
                emit(node.children[i]);
            }
            state.shift();
        }
        state = incoming_state;
        tokens = incoming_tokens;
        idx = 0;
        var result;
        if (!tokens.length) {
            return;
        }
        advance();
        result = expression(0);
        result.parent = state[0];
        emit(result);
        if (idx &lt; tokens.length) {
            throw new Error(&#x27;did not use all tokens&#x27;);
        }
        result.parent.children = [result];
    }
    /**
     * The heart of top-down precedence parsing (Pratt).
     * @param rbp Right Binding Power.
     */
    function expression(rbp) {
        var left;
        var t = token;
        advance();
        left = t.nud();
        while (rbp &lt; token.lbp) {
            t = token;
            advance();
            left = t.led(left);
        }
        return left;
    }
    /**
     * Make a new token from the next simple object in the array and assign to the token variable
     */
    function advance(id) {
        var next;
        var value;
        var type;
        /**
         * Symbol obtained from the symbol lookup table.
         */
        var output;
        if (id &amp;&amp; token.data !== id) {
            return state.unexpected(&#x27;expected &#x60;&#x27; + id + &#x27;&#x60;, got &#x60;&#x27; + token.data + &#x27;&#x60;&#x27;);
        }
        if (idx &gt;= tokens.length) {
            token = symbol_table[&#x27;(end)&#x27;];
            return;
        }
        next = tokens[idx++];
        value = next.data;
        type = next.type;
        if (type === &#x27;ident&#x27;) {
            output = state.scope.find(value) || state.create_node();
            type = output.type;
        }
        else if (type === &#x27;builtin&#x27;) {
            output = symbol_table[&#x27;(builtin)&#x27;];
        }
        else if (type === &#x27;keyword&#x27;) {
            output = symbol_table[&#x27;(keyword)&#x27;];
        }
        else if (type === &#x27;operator&#x27;) {
            output = symbol_table[value];
            if (!output) {
                return state.unexpected(&#x27;unknown operator &#x60;&#x27; + value + &#x27;&#x60;&#x27;);
            }
        }
        else if (type === &#x27;float&#x27; || type === &#x27;integer&#x27;) {
            type = &#x27;literal&#x27;;
            output = symbol_table[&#x27;(literal)&#x27;];
        }
        else {
            return state.unexpected(&#x27;unexpected token.&#x27;);
        }
        if (output) {
            if (!output.nud) {
                output.nud = itself;
            }
            if (!output.children) {
                output.children = [];
            }
        }
        // FIXME: This should be assigning to token?
        output = Object.create(output);
        output.token = next;
        output.type = type;
        if (!output.data) {
            output.data = value;
        }
        // I don&#x27;t think the assignment is required.
        // It also may be effing up the type safety.
        return token = output;
    }
    return expr;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
