<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/utils/contextProxy.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.81.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribLocation..html">AttribLocation.</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face.html">Face</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Geometry3.html">Geometry3</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line.html">Line</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/Point.html">Point</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/RenderingContextUser.html">RenderingContextUser</a></li>
                                <li><a href="../classes/ShaderProgram.html">ShaderProgram</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/utils/contextProxy.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import ArrayBuffer = require(&#x27;../core/ArrayBuffer&#x27;);
import Elements = require(&#x27;../dfx/Elements&#x27;);
import RenderingContextMonitor = require(&#x27;../core/RenderingContextMonitor&#x27;);
import RenderingContextUser = require(&#x27;../core/RenderingContextUser&#x27;);
import initWebGL = require(&#x27;../renderers/initWebGL&#x27;);
import expectArg = require(&#x27;../checks/expectArg&#x27;);
import isDefined = require(&#x27;../checks/isDefined&#x27;);
import isUndefined = require(&#x27;../checks/isUndefined&#x27;);
import ShaderProgram = require(&#x27;../core/ShaderProgram&#x27;);
import Symbolic = require(&#x27;../core/Symbolic&#x27;);
import Texture = require(&#x27;../resources/Texture&#x27;);
import VectorN = require(&#x27;../math/VectorN&#x27;);

/**
 * This could become an encapsulated call?
 */
class DrawElementsCommand {
  private mode: number;
  private count: number;
  private type: number;
  private offset: number;
  constructor(mode: number, count: number, type: number, offset: number) {
    this.mode = mode;
    this.count = count;
    this.type = type;
    this.offset = offset;
  }
  execute(context: WebGLRenderingContext) {
    context.drawElements(this.mode, this.count, this.type, this.offset);
  }
}

class ElementsBlock {
  public attributes: { [key: string]: ElementsBlockAttrib };
  public indices: ArrayBuffer;
  public drawCommand: DrawElementsCommand;
  constructor(indices: ArrayBuffer, attributes: { [key: string]: ElementsBlockAttrib }, drawCommand: DrawElementsCommand) {
    this.indices = indices;
    this.attributes = attributes;
    this.drawCommand = drawCommand;
  }
}
class ElementsBlockAttrib {
  public buffer: ArrayBuffer;
  public size: number;
  public normalized: boolean;
  public stride: number;
  public offset: number;
  constructor(buffer: ArrayBuffer, size: number, normalized: boolean, stride: number, offset: number) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
  }
}

function isDrawMode(mode: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;mode&#x27;, mode).toBeNumber();
  switch(mode) {
    case context.TRIANGLES: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function isBufferUsage(usage: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;usage&#x27;, usage).toBeNumber();
  switch(usage) {
    case context.STATIC_DRAW: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function messageUnrecognizedToken(token: string): string {
  expectArg(&#x27;token&#x27;, token).toBeString();
  return token + &quot; is not a recognized token&quot;;
}

function assertProgram(argName: string, program: ShaderProgram): void {
  expectArg(argName, program).toBeObject();
}

function attribName(name: string, attribMap?: {[name:string]:string}): string {
  if (isUndefined(attribMap)) {
    return name;
  }
  else {
    let alias = attribMap[name];
    return isDefined(alias) ? alias : name;
  }
}

function contextProxy(canvas: HTMLCanvasElement, attributes?: WebGLContextAttributes): RenderingContextMonitor {

  expectArg(&#x27;canvas&#x27;, canvas).toSatisfy(canvas instanceof HTMLCanvasElement, &quot;canvas argument must be an HTMLCanvasElement&quot;);

  let users: RenderingContextUser[] = [];
  var context: WebGLRenderingContext;
  var refCount: number = 1;
  var mirror: boolean = true;
  let tokenMap: {[name:string]:ElementsBlock} = {};
  let tokenArg = expectArg(&#x27;token&#x27;, &quot;&quot;);

  let webGLContextLost = function(event: Event) {
    event.preventDefault();
    context = void 0;
    users.forEach(function(user: RenderingContextUser) {
      user.contextLoss();
    });
  };

  let webGLContextRestored = function(event: Event) {
    event.preventDefault();
    context = initWebGL(canvas, attributes);
    users.forEach(function(user: RenderingContextUser) {
      user.contextGain(context);
    });
  };

  var self: RenderingContextMonitor = {
    /**
     *
     */
    checkIn(elements: Elements, mode: number, usage?: number): string {
      expectArg(&#x27;elements&#x27;, elements).toSatisfy(elements instanceof Elements, &quot;elements must be an instance of Elements&quot;);
      expectArg(&#x27;mode&#x27;, mode).toSatisfy(isDrawMode(mode, context), &quot;mode must be one of TRIANGLES, ...&quot;);
      if (isDefined(usage)) {
        expectArg(&#x27;usage&#x27;, usage).toSatisfy(isBufferUsage(usage, context), &quot;usage must be on of STATIC_DRAW, ...&quot;);
      }
      else {
        usage = context.STATIC_DRAW;
      }
      let token: string = Math.random().toString();
      let indexBuffer = self.vertexBuffer();
      indexBuffer.bind(context.ELEMENT_ARRAY_BUFFER);
      context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(elements.indices.data), usage);
      context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, null);
      // attributes
      let attributes: { [name: string]: ElementsBlockAttrib } = {};
      Object.keys(elements.attributes).forEach(function(name: string) {
        let buffer = self.vertexBuffer();
        buffer.bind(context.ARRAY_BUFFER);
        let vertexAttrib = elements.attributes[name];
        let data: number[] = vertexAttrib.vector.data;
        context.bufferData(context.ARRAY_BUFFER, new Float32Array(data), usage);
        context.bindBuffer(context.ARRAY_BUFFER, null);
        // normalized, stride and offset in future may not be zero.
        attributes[name] = new ElementsBlockAttrib(buffer, vertexAttrib.size, false, 0, 0);
      });
      // Use UNSIGNED_BYTE  if ELEMENT_ARRAY_BUFFER is a Uint8Array.
      // Use UNSIGNED_SHORT if ELEMENT_ARRAY_BUFFER is a Uint16Array.
      let offset = 0; // Later we may set this differently if we reuse buffers.
      let drawCommand = new DrawElementsCommand(mode, elements.indices.length, context.UNSIGNED_SHORT, offset);
      tokenMap[token] = new ElementsBlock(indexBuffer, attributes, drawCommand);
      return token;
    },
    setUp(token: string, program: ShaderProgram, attribMap?: {[name:string]:string}): void {
      let blob = tokenMap[token];
      if (isDefined(blob)) {
        if (isDefined(program)) {
          let indices = blob.indices;
          indices.bind(context.ELEMENT_ARRAY_BUFFER);

          // FIXME: Probably better to work from the program attributes?
          Object.keys(blob.attributes).forEach(function(key: string) {
            let aName: string = attribName(key, attribMap);
            let aLocation = program.attributes[aName];
            if (isDefined(aLocation)) {
              let attribute: ElementsBlockAttrib = blob.attributes[key];
              attribute.buffer.bind(context.ARRAY_BUFFER);
              aLocation.vertexPointer(attribute.size, attribute.normalized, attribute.stride, attribute.offset);
              context.bindBuffer(context.ARRAY_BUFFER, null);
            }
            else {
              // The attribute available may not be required by the program.
              // TODO: (1) Named programs, (2) disable warning by attribute.
              // console.warn(&quot;attribute &quot; + aName + &quot; is not being used by the program&quot;);
            }
          });
        }
        else {
          assertProgram(&#x27;program&#x27;, program);
        }
      }
      else {
        throw new Error(messageUnrecognizedToken(token));
      }
    },
    draw(token: string): void {
      let blob = tokenMap[token];
      if (isDefined(blob)) {
        blob.drawCommand.execute(context);
      }
      else {
        throw new Error(messageUnrecognizedToken(token));
      }
    },
    tearDown(token: string, program: ShaderProgram): void {
      let blob = tokenMap[token];
      if (isDefined(blob)) {
        context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, null);
      }
      else {
        throw new Error(messageUnrecognizedToken(token));
      }
    },
    checkOut(token: string): void {
      let blob = tokenMap[token];
      if (isDefined(blob)) {
        let indices = blob.indices;
        self.removeContextUser(indices);
        Object.keys(blob.attributes).forEach(function(key:string) {
          let attribute = blob.attributes[key];
          let buffer = attribute.buffer;
          self.removeContextUser(buffer);
        });
        delete tokenMap[token];
      }
      else {
        throw new Error(messageUnrecognizedToken(token));
      }
    },
    start(): RenderingContextMonitor {
      context = initWebGL(canvas, attributes);
      canvas.addEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      canvas.addEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      users.forEach(function(user: RenderingContextUser) {user.contextGain(context);});
      return self;
    },
    stop(): RenderingContextMonitor {
      context = void 0;
      users.forEach(function(user: RenderingContextUser) {user.contextFree();});
      canvas.removeEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      canvas.removeEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      return self;
    },
    addContextUser(user: RenderingContextUser): RenderingContextMonitor {
      expectArg(&#x27;user&#x27;, user).toBeObject();
      user.addRef();
      users.push(user);
      if (context) {
        user.contextGain(context)
      }
      return self;
    },
    removeContextUser(user: RenderingContextUser): RenderingContextMonitor {
      expectArg(&#x27;user&#x27;, user).toBeObject();
      let index = users.indexOf(user);
      if (index &gt;= 0) {
        users.splice(index, 1);
        user.release();
      }
      return self;
    },
    get context() {
      if (isDefined(context)) {
        return context;
      }
      else {
        console.warn(&quot;property context: WebGLRenderingContext is not defined. Either context has been lost or start() not called.&quot;);
        return void 0;
      }
    },
    addRef(): number {
      refCount++;
      // console.log(&quot;monitor.addRef() =&gt; &quot; + refCount);
      return refCount;
    },
    release(): number {
      refCount--;
      // console.log(&quot;monitor.release() =&gt; &quot; + refCount);
      if (refCount === 0) {
        while(users.length &gt; 0) {
          users.pop().release();
        }
      }
      return refCount;
    },
    clearColor(red: number, green: number, blue: number, alpha: number): void {
      if (context) {
        return context.clearColor(red, green, blue, alpha);
      }
    },
    clearDepth(depth: number): void {
      if (context) {
        return context.clearDepth(depth);
      }
    },
    drawArrays(mode: number, first: number, count: number): void {
      if (context) {
        return context.drawArrays(mode, first, count);
      }
    },
    drawElements(mode: number, count: number, type: number, offset: number): void {
      if (context) {
        return context.drawElements(mode, count, type, offset);
      }
    },
    depthFunc(func: number): void {
      if (context) {
        return context.depthFunc(func);
      }
    },
    enable(capability: number): void {
      if (context) {
        return context.enable(capability);
      }
    },
    texture(): Texture {
      let texture = new Texture(self);
      self.addContextUser(texture);
      return texture;
    },
    vertexBuffer(): ArrayBuffer {
      let vbo = new ArrayBuffer(self);
      self.addContextUser(vbo);
      return vbo;
    },
    get mirror() {
      return mirror;
    },
    set mirror(value: boolean) {
      mirror = expectArg(&#x27;mirror&#x27;, value).toBeBoolean().value;
    }
  };
  return self;
}

export = contextProxy;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
