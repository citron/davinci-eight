<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/utils/contextProxy.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.82.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribLocation..html">AttribLocation.</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face.html">Face</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Geometry3.html">Geometry3</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line.html">Line</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/Point.html">Point</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/RenderingContextUser.html">RenderingContextUser</a></li>
                                <li><a href="../classes/ShaderProgram.html">ShaderProgram</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/utils/contextProxy.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import ArrayBuffer = require(&#x27;../core/ArrayBuffer&#x27;);
import Mesh = require(&#x27;../dfx/Mesh&#x27;);
import Elements = require(&#x27;../dfx/Elements&#x27;);
import RenderingContextMonitor = require(&#x27;../core/RenderingContextMonitor&#x27;);
import RenderingContextUser = require(&#x27;../core/RenderingContextUser&#x27;);
import initWebGL = require(&#x27;../renderers/initWebGL&#x27;);
import IUnknown = require(&#x27;../core/IUnknown&#x27;)
import expectArg = require(&#x27;../checks/expectArg&#x27;);
import isDefined = require(&#x27;../checks/isDefined&#x27;);
import isUndefined = require(&#x27;../checks/isUndefined&#x27;);
import RefCount = require(&#x27;../utils/RefCount&#x27;);
import refChange = require(&#x27;../utils/refChange&#x27;);
import ShaderProgram = require(&#x27;../core/ShaderProgram&#x27;);
import Symbolic = require(&#x27;../core/Symbolic&#x27;);
import Texture = require(&#x27;../resources/Texture&#x27;);
import VectorN = require(&#x27;../math/VectorN&#x27;);
import uuid4 = require(&#x27;../utils/uuid4&#x27;);

/**
 * This could become an encapsulated call?
 */
class DrawElementsCommand {
  private mode: number;
  private count: number;
  private type: number;
  private offset: number;
  constructor(mode: number, count: number, type: number, offset: number) {
    this.mode = mode;
    this.count = count;
    this.type = type;
    this.offset = offset;
  }
  execute(context: WebGLRenderingContext) {
    context.drawElements(this.mode, this.count, this.type, this.offset);
  }
}

class ElementsBlock implements IUnknown {
  private _attributes: { [key: string]: ElementsBlockAttrib };
  private _indexBuffer: ArrayBuffer;
  public drawCommand: DrawElementsCommand;
  private _refCount = 1;
  private _uuid: string = uuid4().generate();
  constructor(indexBuffer: ArrayBuffer, attributes: { [key: string]: ElementsBlockAttrib }, drawCommand: DrawElementsCommand) {

    this._indexBuffer = indexBuffer;
    this._indexBuffer.addRef();

    this._attributes = attributes;
    Object.keys(attributes).forEach(function(key: string) {
      attributes[key].addRef();
    });

    this.drawCommand = drawCommand;

    refChange(this._uuid, +1, &#x27;ElementsBlock&#x27;);
  }
  get indexBuffer() {
    this._indexBuffer.addRef();
    return this._indexBuffer;
  }
  addRef(): number {
    refChange(this._uuid, +1, &#x27;ElementsBlock&#x27;);
    this._refCount++;
    return this._refCount;
  }
  release(): number {
    refChange(this._uuid, -1, &#x27;ElementsBlock&#x27;);
    this._refCount--;
    if (this._refCount === 0) {

      let attributes = this._attributes;
      Object.keys(attributes).forEach(function(key: string) {
        attributes[key].release();
      });
      this._attributes = void 0;

      this._indexBuffer.release();
      this._indexBuffer = void 0;

      this.drawCommand = void 0;
      this._uuid = void 0;

      let refCount = this._refCount;
      this._refCount = 0;
      return refCount;
    }
    else {
      return this._refCount;
    }
  }
  get attributes() {
    return this._attributes;
  }
}
class ElementsBlockAttrib implements IUnknown {
  private _buffer: ArrayBuffer;
  public size: number;
  public normalized: boolean;
  public stride: number;
  public offset: number;
  private _refCount = 1;
  private _uuid: string = uuid4().generate();
  constructor(buffer: ArrayBuffer, size: number, normalized: boolean, stride: number, offset: number) {
    this._buffer = buffer;
    this._buffer.addRef();
    this.size = size;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
    refChange(this._uuid, +1, &#x27;ElementsBlockAttrib&#x27;);
  }
  addRef(): number {
    refChange(this._uuid, +1, &#x27;ElementsBlockAttrib&#x27;);
    this._refCount++;
    return this._refCount;
  }
  release(): number {
    refChange(this._uuid, -1, &#x27;ElementsBlockAttrib&#x27;);
    this._refCount--;
    if (this._refCount === 0) {
      this._buffer.release();
      this._buffer = void 0;
      this.size = void 0;
      this.normalized = void 0;
      this.stride = void 0;
      this.offset = void 0;
      this._uuid = void 0;
    }
    return this._refCount;
  }
  get buffer() {
    this._buffer.addRef();
    return this._buffer;
  }
}

function isDrawMode(mode: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;mode&#x27;, mode).toBeNumber();
  switch(mode) {
    case context.TRIANGLES: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function isBufferUsage(usage: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;usage&#x27;, usage).toBeNumber();
  switch(usage) {
    case context.STATIC_DRAW: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function messageUnrecognizedToken(token: string): string {
  expectArg(&#x27;token&#x27;, token).toBeString();
  return token + &quot; is not a recognized token&quot;;
}

function assertProgram(argName: string, program: ShaderProgram): void {
  expectArg(argName, program).toBeObject();
}

function attribKey(aName: string, aNameToKeyName?: {[aName: string]: string}): string {
  if (isUndefined(aNameToKeyName)) {
    return aName;
  }
  else {
    let key = aNameToKeyName[aName];
    return isDefined(key) ? key : aName;
  }
}

function contextProxy(canvas: HTMLCanvasElement, attributes?: WebGLContextAttributes): RenderingContextMonitor {

  expectArg(&#x27;canvas&#x27;, canvas).toSatisfy(canvas instanceof HTMLCanvasElement, &quot;canvas argument must be an HTMLCanvasElement&quot;);
  let uuid: string = uuid4().generate();
  let tokenMap: {[name:string]:ElementsBlock} = {};
  let users: RenderingContextUser[] = [];

  function addContextUser(user: RenderingContextUser): void {
    expectArg(&#x27;user&#x27;, user).toBeObject();
    users.push(user);
    user.addRef();
    if (context) {
      user.contextGain(context);
    }
  }

  function removeContextUser(user: RenderingContextUser): void {
    expectArg(&#x27;user&#x27;, user).toBeObject();
    let index = users.indexOf(user);
    if (index &gt;= 0) {
      let removals = users.splice(index, 1);
      removals.forEach(function(user){
        user.release();
      });
    }
  }

  function drawTokenDelete(uuid: string) {
    return function() {
      let blob = tokenMap[uuid];
      if (isDefined(blob)) {

        let indexBuffer = blob.indexBuffer;
        removeContextUser(indexBuffer);
        indexBuffer.release();
        indexBuffer = void 0;

        Object.keys(blob.attributes).forEach(function(key:string) {
          let attribute = blob.attributes[key];

          let buffer = attribute.buffer;
          try {
            removeContextUser(buffer);
          }
          finally {
            buffer.release();
            buffer = void 0;
          }
        });
        blob.release();
        delete tokenMap[uuid];
      }
      else {
        throw new Error(messageUnrecognizedToken(uuid));
      }
    }
  }

  function drawToken(uuid: string): Mesh {

    let refCount = new RefCount(drawTokenDelete(uuid));
    let _program: ShaderProgram = void 0;
    let self: Mesh = {
      addRef(): number {
        refChange(uuid, +1, &#x27;Mesh&#x27;);
        return refCount.addRef();
      },
      release(): number {
        refChange(uuid, -1, &#x27;Mesh&#x27;);
        return refCount.release();
      },
      get uuid() {
        return uuid;
      },
      bind(program: ShaderProgram, aNameToKeyName?: {[name: string]: string}): void {
        if (_program !== program) {
          if (_program) {
            self.unbind();
          }
          let blob = tokenMap[uuid];
          if (isDefined(blob)) {
            if (isDefined(program)) {

              let indexBuffer = blob.indexBuffer;
              indexBuffer.bind(context.ELEMENT_ARRAY_BUFFER);
              indexBuffer.release();
              indexBuffer = void 0;

              // FIXME: We&#x27;re doing a lot of string-based lookup!
              Object.keys(program.attributes).forEach(function(aName: string) {
                let key: string = attribKey(aName, aNameToKeyName);
                let attribute: ElementsBlockAttrib = blob.attributes[key];
                if (isDefined(attribute)) {
                  // Associate the attribute buffer with the attribute location.
                  let buffer = attribute.buffer;
                  try {
                    buffer.bind(context.ARRAY_BUFFER);
                    try {
                      let attributeLocation = program.attributes[aName];
                      attributeLocation.vertexPointer(attribute.size, attribute.normalized, attribute.stride, attribute.offset);

                      attributeLocation.enable();
                    }
                    finally {
                      context.bindBuffer(context.ARRAY_BUFFER, null);
                    }
                  }
                  finally {
                    buffer.release();
                    buffer = void 0;
                  }
                }
                else {
                  // The attribute available may not be required by the program.
                  // TODO: (1) Named programs, (2) disable warning by attribute?
                  // Do not allow Attribute 0 to be disabled.
                  console.warn(&quot;program attribute &quot; + aName + &quot; is not satisfied by the token&quot;);
                }
              });
            }
            else {
              assertProgram(&#x27;program&#x27;, program);
            }
          }
          else {
            throw new Error(messageUnrecognizedToken(uuid));
          }
          _program = program;
          _program.addRef();
        }
      },
      draw(): void {
        let blob = tokenMap[uuid];
        if (isDefined(blob)) {
          blob.drawCommand.execute(context);
        }
        else {
          throw new Error(messageUnrecognizedToken(uuid));
        }
      },
      unbind(): void {
        if (_program) {
          let blob = tokenMap[uuid];
          if (isDefined(blob)) {
            context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, null);

            Object.keys(_program.attributes).forEach(function(aName: string) {
              let aLocation = _program.attributes[aName];
              // Disable the attribute location.
              aLocation.disable();
            });
          }
          else {
            throw new Error(messageUnrecognizedToken(uuid));
          }
          _program.release();
          _program = void 0;
        }
      }
    };
    refChange(uuid, +1, &#x27;Mesh&#x27;);
    return self;
  }

  var context: WebGLRenderingContext;
  var refCount: number = 1;
  var mirror: boolean = true;
  let tokenArg = expectArg(&#x27;token&#x27;, &quot;&quot;);

  let webGLContextLost = function(event: Event) {
    event.preventDefault();
    context = void 0;
    users.forEach(function(user: RenderingContextUser) {
      user.contextLoss();
    });
  };

  let webGLContextRestored = function(event: Event) {
    event.preventDefault();
    context = initWebGL(canvas, attributes);
    users.forEach(function(user: RenderingContextUser) {
      user.contextGain(context);
    });
  };

  let self: RenderingContextMonitor = {
    /**
     *
     */
    createMesh(elements: Elements, mode: number, usage?: number): Mesh {
      expectArg(&#x27;elements&#x27;, elements).toSatisfy(elements instanceof Elements, &quot;elements must be an instance of Elements&quot;);
      expectArg(&#x27;mode&#x27;, mode).toSatisfy(isDrawMode(mode, context), &quot;mode must be one of TRIANGLES, ...&quot;);
      if (isDefined(usage)) {
        expectArg(&#x27;usage&#x27;, usage).toSatisfy(isBufferUsage(usage, context), &quot;usage must be on of STATIC_DRAW, ...&quot;);
      }
      else {
        usage = context.STATIC_DRAW;
      }

      let token: Mesh = drawToken(uuid4().generate());

      let indexBuffer = self.vertexBuffer();
      try {
        indexBuffer.bind(context.ELEMENT_ARRAY_BUFFER);
        context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(elements.indices.data), usage);
        context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, null);

        // attributes
        let attributes: { [name: string]: ElementsBlockAttrib } = {};
        try {
          Object.keys(elements.attributes).forEach(function(name: string) {
            let buffer = self.vertexBuffer();
            try {
              buffer.bind(context.ARRAY_BUFFER);
              try {
                let vertexAttrib = elements.attributes[name];
                let data: number[] = vertexAttrib.vector.data;
                context.bufferData(context.ARRAY_BUFFER, new Float32Array(data), usage);
                attributes[name] = new ElementsBlockAttrib(buffer, vertexAttrib.size, false, 0, 0);
              }
              finally {
                context.bindBuffer(context.ARRAY_BUFFER, null);
              }
            }
            finally {
              buffer.release();
              buffer = void 0;
            }
          });
          // Use UNSIGNED_BYTE  if ELEMENT_ARRAY_BUFFER is a Uint8Array.
          // Use UNSIGNED_SHORT if ELEMENT_ARRAY_BUFFER is a Uint16Array.
          let drawCommand = new DrawElementsCommand(mode, elements.indices.length, context.UNSIGNED_SHORT, 0);
          tokenMap[token.uuid] = new ElementsBlock(indexBuffer, attributes, drawCommand);
        }
        finally {
          Object.keys(attributes).forEach(function(key: string){
            let attribute: ElementsBlockAttrib = attributes[key];
            attribute.release();
          });
        }
      }
      finally {
        indexBuffer.release();
        indexBuffer = void 0;
      }
      return token;
    },
    start(): RenderingContextMonitor {
      context = initWebGL(canvas, attributes);
      canvas.addEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      canvas.addEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      users.forEach(function(user: RenderingContextUser) {user.contextGain(context);});
      return self;
    },
    stop(): RenderingContextMonitor {
      context = void 0;
      users.forEach(function(user: RenderingContextUser) {user.contextFree();});
      canvas.removeEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      canvas.removeEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      return self;
    },
    addContextUser(user: RenderingContextUser): RenderingContextMonitor {
      addContextUser(user);
      return self;
    },
    removeContextUser(user: RenderingContextUser): RenderingContextMonitor {
      removeContextUser(user);
      return self;
    },
    get context() {
      if (isDefined(context)) {
        return context;
      }
      else {
        console.warn(&quot;property context: WebGLRenderingContext is not defined. Either context has been lost or start() not called.&quot;);
        return void 0;
      }
    },
    addRef(): number {
      refChange(uuid, +1, &#x27;RenderingContextMonitor&#x27;);
      refCount++;
      return refCount;
    },
    release(): number {
      refChange(uuid, -1, &#x27;RenderingContextMonitor&#x27;);
      refCount--;
      if (refCount === 0) {
        while(users.length &gt; 0) {
          let user = users.pop();
          user.release();
        }
      }
      return refCount;
    },
    clearColor(red: number, green: number, blue: number, alpha: number): void {
      if (context) {
        return context.clearColor(red, green, blue, alpha);
      }
    },
    clearDepth(depth: number): void {
      if (context) {
        return context.clearDepth(depth);
      }
    },
    drawArrays(mode: number, first: number, count: number): void {
      if (context) {
        return context.drawArrays(mode, first, count);
      }
    },
    drawElements(mode: number, count: number, type: number, offset: number): void {
      if (context) {
        return context.drawElements(mode, count, type, offset);
      }
    },
    depthFunc(func: number): void {
      if (context) {
        return context.depthFunc(func);
      }
    },
    enable(capability: number): void {
      if (context) {
        return context.enable(capability);
      }
    },
    texture(): Texture {
      let texture = new Texture(self);
      self.addContextUser(texture);
      return texture;
    },
    vertexBuffer(): ArrayBuffer {
      let vbo = new ArrayBuffer(self);
      self.addContextUser(vbo);
      return vbo;
    },
    get mirror() {
      return mirror;
    },
    set mirror(value: boolean) {
      mirror = expectArg(&#x27;mirror&#x27;, value).toBeBoolean().value;
    }
  };
  refChange(uuid, +1, &#x27;RenderingContextMonitor&#x27;);
  return self;
}

export = contextProxy;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
