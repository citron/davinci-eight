<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/utils/contextProxy.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.91.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribLocation..html">AttribLocation.</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/ContextListener.html">ContextListener</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Geometry3.html">Geometry3</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/Program.html">Program</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Simplex.html">Simplex</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/utils/contextProxy.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Buffer = require(&#x27;../core/Buffer&#x27;);
import BufferResource = require(&#x27;../core/BufferResource&#x27;);
import Mesh = require(&#x27;../dfx/Mesh&#x27;);
import DrawElements = require(&#x27;../dfx/DrawElements&#x27;);
import ContextManager = require(&#x27;../core/ContextManager&#x27;);
import ContextListener = require(&#x27;../core/ContextListener&#x27;);
import initWebGL = require(&#x27;../renderers/initWebGL&#x27;);
import IUnknown = require(&#x27;../core/IUnknown&#x27;)
import expectArg = require(&#x27;../checks/expectArg&#x27;);
import isDefined = require(&#x27;../checks/isDefined&#x27;);
import isUndefined = require(&#x27;../checks/isUndefined&#x27;);
import IUnknownMap = require(&#x27;../utils/IUnknownMap&#x27;);
import RefCount = require(&#x27;../utils/RefCount&#x27;);
import refChange = require(&#x27;../utils/refChange&#x27;);
import Program = require(&#x27;../core/Program&#x27;);
import Symbolic = require(&#x27;../core/Symbolic&#x27;);
import Texture = require(&#x27;../core/Texture&#x27;);
import TextureResource = require(&#x27;../resources/TextureResource&#x27;);
import VectorN = require(&#x27;../math/VectorN&#x27;);
import uuid4 = require(&#x27;../utils/uuid4&#x27;);

let LOGGING_NAME_ELEMENTS_BLOCK = &#x27;ElementsBlock&#x27;;
let LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE = &#x27;ElementsBlockAttrib&#x27;;
let LOGGING_NAME_MESH = &#x27;Mesh&#x27;;
let LOGGING_NAME_MANAGER = &#x27;ContextManager&#x27;;

function mustBeContext(context: WebGLRenderingContext, method: string): WebGLRenderingContext {
  if (context) {
    return context;
  }
  else {
    throw new Error(method + &quot;: context: WebGLRenderingContext is not defined. Either context has been lost or start() not called.&quot;);
  }
}

/**
 * This could become an encapsulated call?
 */
class DrawElementsCommand {
  private mode: number;
  private count: number;
  private type: number;
  private offset: number;
  constructor(mode: number, count: number, type: number, offset: number) {
    this.mode = mode;
    this.count = count;
    this.type = type;
    this.offset = offset;
  }
  execute(context: WebGLRenderingContext) {
    context.drawElements(this.mode, this.count, this.type, this.offset);
  }
}

class ElementsBlock implements IUnknown {
  private _attributes: IUnknownMap&lt;ElementsBlockAttrib&gt;;
  private _indexBuffer: Buffer;
  public drawCommand: DrawElementsCommand;
  private _refCount = 1;
  private _uuid: string = uuid4().generate();
  constructor(indexBuffer: Buffer, attributes: IUnknownMap&lt;ElementsBlockAttrib&gt;, drawCommand: DrawElementsCommand) {

    this._indexBuffer = indexBuffer;
    this._indexBuffer.addRef();

    this._attributes = attributes;
    this._attributes.addRef();

    this.drawCommand = drawCommand;

    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK, +1);
  }
  get indexBuffer(): Buffer {
    this._indexBuffer.addRef();
    return this._indexBuffer;
  }
  addRef(): number {
    this._refCount++;
    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK, +1);
    return this._refCount;
  }
  release(): number {
    this._refCount--;
    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK, -1);
    if (this._refCount === 0) {
      this._attributes.release();
      this._indexBuffer.release();
    }
    return this._refCount;
  }
  get attributes(): IUnknownMap&lt;ElementsBlockAttrib&gt; {
    this._attributes.addRef();
    return this._attributes;
  }
}
class ElementsBlockAttrib implements IUnknown {
  private _buffer: Buffer;
  public size: number;
  public normalized: boolean;
  public stride: number;
  public offset: number;
  private _refCount = 1;
  private _uuid: string = uuid4().generate();
  constructor(buffer: Buffer, size: number, normalized: boolean, stride: number, offset: number) {
    this._buffer = buffer;
    this._buffer.addRef();
    this.size = size;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE, +1);
  }
  addRef(): number {
    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE, +1);
    this._refCount++;
    return this._refCount;
  }
  release(): number {
    refChange(this._uuid, LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE, -1);
    this._refCount--;
    if (this._refCount === 0) {
      this._buffer.release();
    }
    return this._refCount;
  }
  get buffer() {
    this._buffer.addRef();
    return this._buffer;
  }
}

function isDrawMode(mode: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;mode&#x27;, mode).toBeNumber();
  switch(mode) {
    case context.TRIANGLES: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function isBufferUsage(usage: number, context: WebGLRenderingContext): boolean {
  expectArg(&#x27;usage&#x27;, usage).toBeNumber();
  switch(usage) {
    case context.STATIC_DRAW: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function messageUnrecognizedMesh(meshUUID: string): string {
  expectArg(&#x27;meshUUID&#x27;, meshUUID).toBeString();
  return meshUUID + &quot; is not a recognized mesh uuid&quot;;
}

function attribKey(aName: string, aNameToKeyName?: {[aName: string]: string}): string {
  if (aNameToKeyName) {
    let key = aNameToKeyName[aName];
    return key ? key : aName;
  }
  else {
    return aName;
  }
}

function contextProxy(canvas: HTMLCanvasElement, attributes?: WebGLContextAttributes): ContextManager {

  expectArg(&#x27;canvas&#x27;, canvas).toSatisfy(canvas instanceof HTMLCanvasElement, &quot;canvas argument must be an HTMLCanvasElement&quot;);
  let uuid: string = uuid4().generate();
  let blocks = new IUnknownMap&lt;ElementsBlock&gt;();
  // Remark: We only hold weak references to users so that the lifetime of resource
  // objects is not affected by the fact that they are listening for context events.
  // Users should automatically add themselves upon construction and remove upon release.
  let users: ContextListener[] = [];

  function addContextListener(user: ContextListener): void {
    expectArg(&#x27;user&#x27;, user).toBeObject();
    users.push(user);
    if (context) {
      user.contextGain(context);
    }
  }

  function removeContextListener(user: ContextListener): void {
    expectArg(&#x27;user&#x27;, user).toBeObject();
    let index = users.indexOf(user);
    if (index &gt;= 0) {
      let removals = users.splice(index, 1);
      removals.forEach(function(user: ContextListener){
      });
    }
  }

  function meshRemover(blockUUID: string) {
    return function() {
      if (blocks.exists(blockUUID)) {
        blocks.remove(blockUUID);
      }
      else {
        console.warn(&quot;[System Error] &quot; + messageUnrecognizedMesh(blockUUID));
      }
    }
  }

  function createDrawElementsMesh(uuid: string): Mesh {

    let refCount = new RefCount(meshRemover(uuid));
    let _program: Program = void 0;
    let mesh: Mesh = {
      addRef(): number {
        refChange(uuid, LOGGING_NAME_MESH, +1);
        return refCount.addRef();
      },
      release(): number {
        refChange(uuid, LOGGING_NAME_MESH, -1);
        return refCount.release();
      },
      get uuid() {
        return uuid;
      },
      bind(program: Program, aNameToKeyName?: {[name: string]: string}): void {
        if (_program !== program) {
          if (_program) {
            mesh.unbind();
          }
          let block= blocks.get(uuid);
          if (block) {
            if (program) {
              _program = program;
              _program.addRef();

              let indexBuffer = block.indexBuffer;
              indexBuffer.bind();
              indexBuffer.release();

              let aNames = Object.keys(program.attributes);
              let aNamesLength = aNames.length;
              var aNamesIndex: number;
              for (aNamesIndex = 0; aNamesIndex &lt; aNamesLength; aNamesIndex++) {
                let aName = aNames[aNamesIndex];
                let key: string = attribKey(aName, aNameToKeyName);
                let attributes = block.attributes;
                let attribute = attributes.get(key);
                if (attribute) {
                  // Associate the attribute buffer with the attribute location.
                  let buffer = attribute.buffer;
                  buffer.bind();
                  let attributeLocation = program.attributes[aName];
                  attributeLocation.vertexPointer(attribute.size, attribute.normalized, attribute.stride, attribute.offset);
                  buffer.unbind();

                  attributeLocation.enable();
                  buffer.release();
                  attribute.release();
                }
                else {
                  // The attribute available may not be required by the program.
                  // TODO: (1) Named programs, (2) disable warning by attribute?
                  // Do not allow Attribute 0 to be disabled.
                  console.warn(&quot;program attribute &quot; + aName + &quot; is not satisfied by the mesh&quot;);
                }
                attributes.release();
              }
            }
            else {
              expectArg(&#x27;program&#x27;, program).toBeObject();
            }
            block.release();
          }
          else {
            throw new Error(messageUnrecognizedMesh(uuid));
          }
        }
      },
      draw(): void {
        let block = blocks.get(uuid);
        if (block) {
          block.drawCommand.execute(context);
          block.release();
        }
        else {
          throw new Error(messageUnrecognizedMesh(uuid));
        }
      },
      unbind(): void {
        if (_program) {
          let block = blocks.get(uuid);
          if (block) {
            let indexBuffer = block.indexBuffer;
            indexBuffer.unbind();
            indexBuffer.release();

            Object.keys(_program.attributes).forEach(function(aName: string) {
              _program.attributes[aName].disable();
            });
            block.release();
          }
          else {
            throw new Error(messageUnrecognizedMesh(uuid));
          }
          _program.release();
          // Important! The existence of _program indicates the binding state.
          _program = void 0;
        }
      }
    };
    refChange(uuid, LOGGING_NAME_MESH, +1);
    return mesh;
  }

  var context: WebGLRenderingContext;
  var refCount: number = 1;
  var mirror: boolean = false;
  let tokenArg = expectArg(&#x27;token&#x27;, &quot;&quot;);

  let webGLContextLost = function(event: Event) {
    event.preventDefault();
    context = void 0;
    users.forEach(function(user: ContextListener) {
      user.contextLoss();
    });
  };

  let webGLContextRestored = function(event: Event) {
    event.preventDefault();
    context = initWebGL(canvas, attributes);
    users.forEach(function(user: ContextListener) {
      user.contextGain(context);
    });
  };

  let monitor: ContextManager = {
    /**
     *
     */
    createDrawElementsMesh(elements: DrawElements, mode: number, usage?: number): Mesh {
      expectArg(&#x27;elements&#x27;, elements).toSatisfy(elements instanceof DrawElements, &quot;elements must be an instance of DrawElements&quot;);
      expectArg(&#x27;mode&#x27;, mode).toSatisfy(isDrawMode(mode, context), &quot;mode must be one of TRIANGLES, ...&quot;);
      if (isDefined(usage)) {
        expectArg(&#x27;usage&#x27;, usage).toSatisfy(isBufferUsage(usage, context), &quot;usage must be on of STATIC_DRAW, ...&quot;);
      }
      else {
        usage = context.STATIC_DRAW;
      }

      let token: Mesh = createDrawElementsMesh(uuid4().generate());

      let indexBuffer = monitor.createElementArrayBuffer();
      indexBuffer.bind();
      context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(elements.indices.data), usage);
      indexBuffer.unbind();

      let attributes = new IUnknownMap&lt;ElementsBlockAttrib&gt;();
      let names = Object.keys(elements.attributes);
      let namesLength = names.length;
      var i: number;
      for (i = 0; i &lt; namesLength; i++) {
        let name = names[i];
        let buffer = monitor.createArrayBuffer();
        buffer.bind();
        let vertexAttrib = elements.attributes[name];
        let data: number[] = vertexAttrib.values.data;
        context.bufferData(context.ARRAY_BUFFER, new Float32Array(data), usage);
        let attribute = new ElementsBlockAttrib(buffer, vertexAttrib.size, false, 0, 0);
        attributes.put(name, attribute);
        attribute.release();
        buffer.unbind();
        buffer.release();
      }
      // Use UNSIGNED_BYTE  if ELEMENT_ARRAY_BUFFER is a Uint8Array.
      // Use UNSIGNED_SHORT if ELEMENT_ARRAY_BUFFER is a Uint16Array.
      let drawCommand = new DrawElementsCommand(mode, elements.indices.length, context.UNSIGNED_SHORT, 0);
      let block = new ElementsBlock(indexBuffer, attributes, drawCommand);
      blocks.put(token.uuid, block);
      block.release();
      attributes.release();
      indexBuffer.release();
      return token;
    },
    start(): ContextManager {
      context = initWebGL(canvas, attributes);
      canvas.addEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      canvas.addEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      users.forEach(function(user: ContextListener) {user.contextGain(context);});
      return monitor;
    },
    stop(): ContextManager {
      context = void 0;
      users.forEach(function(user: ContextListener) {user.contextFree();});
      canvas.removeEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false);
      canvas.removeEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false);
      return monitor;
    },
    addContextListener(user: ContextListener): ContextManager {
      addContextListener(user);
      return monitor;
    },
    removeContextListener(user: ContextListener): ContextManager {
      removeContextListener(user);
      return monitor;
    },
    get context() {
      if (context) {
        return context;
      }
      else {
        console.warn(&quot;property context: WebGLRenderingContext is not defined. Either context has been lost or start() not called.&quot;);
        return void 0;
      }
    },
    addRef(): number {
      refChange(uuid, LOGGING_NAME_MANAGER, +1);
      refCount++;
      return refCount;
    },
    release(): number {
      refChange(uuid, LOGGING_NAME_MANAGER, -1);
      refCount--;
      if (refCount === 0) {
        blocks.release();
        while(users.length &gt; 0) {
          let user = users.pop();
        }
      }
      return refCount;
    },
    clearColor(red: number, green: number, blue: number, alpha: number): void {
      if (context) {
        return context.clearColor(red, green, blue, alpha);
      }
    },
    clearDepth(depth: number): void {
      if (context) {
        return context.clearDepth(depth);
      }
    },
    drawArrays(mode: number, first: number, count: number): void {
      if (context) {
        return context.drawArrays(mode, first, count);
      }
    },
    drawElements(mode: number, count: number, type: number, offset: number): void {
      if (context) {
        return context.drawElements(mode, count, type, offset);
      }
    },
    depthFunc(func: number): void {
      if (context) {
        return context.depthFunc(func);
      }
    },
    enable(capability: number): void {
      if (context) {
        return context.enable(capability);
      }
    },
    createArrayBuffer(): Buffer {
      // TODO: Replace with functional constructor pattern.
      return new BufferResource(monitor, mustBeContext(context, &#x27;createArrayBuffer()&#x27;).ARRAY_BUFFER);
    },
    createElementArrayBuffer(): Buffer {
      // TODO: Replace with functional constructor pattern.
      return new BufferResource(monitor, mustBeContext(context, &#x27;createElementArrayBuffer()&#x27;).ELEMENT_ARRAY_BUFFER);
    },
    createTexture2D(): Texture {
      // TODO: Replace with functional constructor pattern.
      return new TextureResource(monitor, mustBeContext(context, &#x27;createTexture2D()&#x27;).TEXTURE_2D);
    },
    createTextureCubeMap(): Texture {
      // TODO: Replace with functional constructor pattern.
      return new TextureResource(monitor, mustBeContext(context, &#x27;createTextureCubeMap()&#x27;).TEXTURE_CUBE_MAP);
    },
    get mirror() {
      return mirror;
    },
    set mirror(value: boolean) {
      mirror = expectArg(&#x27;mirror&#x27;, value).toBeBoolean().value;
    }
  };
  refChange(uuid, LOGGING_NAME_MANAGER, +1);
  return monitor;
}

export = contextProxy;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
