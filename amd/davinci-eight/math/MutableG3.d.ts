import GeometricE3 = require('../math/GeometricE3');
import LinearElement = require('../math/LinearElement');
import SpinorE3 = require('../math/SpinorE3');
import VectorE3 = require('../math/VectorE3');
import VectorN = require('../math/VectorN');
/**
 * @class MutableG3
 * @extends GeometricE3
 * @beta
 */
declare class MutableG3 extends VectorN<number> implements GeometricE3, LinearElement<GeometricE3, MutableG3, SpinorE3, VectorE3> {
    /**
     * Constructs a <code>MutableG3</code> from Cartesian coordinates.
     * The coordinates are provided as an array of 8 <code>number</code>s.
     * The corresponding basis is generated by the standard linear space basis, {<b>e</b><sub>1</sub>, <b>e</b><sub>2</sub>, <b>e</b><sub>3</sub>}.
     * The geometric space basis, ordered to correspond with the coordinates, is
     * [1, <b>e</b><sub>1</sub>, <b>e</b><sub>2</sub>, <b>e</b><sub>3</sub>, <b>e</b><sub>2</sub><b>e</b><sub>3</sub>, <b>e</b><sub>3</sub><b>e</b><sub>1</sub>, <b>e</b><sub>1</sub><b>e</b><sub>2</sub>, <b>e</b><sub>1</sub><b>e</b><sub>2</sub><b>e</b><sub>3</sub>].
     * @class MutableG3
     * @beta
     * @constructor
     * @param data [number[] = [0, 0, 0, 0, 0, 0, 0, 0]] The Cartesian coordinates of the multivector.
     */
    constructor(data?: number[]);
    /**
     * The coordinate corresponding to the unit standard basis scalar.
     * @property w
     * @type {number}
     */
    w: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>1</sub> standard basis vector.
     * @property x
     * @type {number}
     */
    x: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>2</sub> standard basis vector.
     * @property y
     * @type {number}
     */
    y: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>3</sub> standard basis vector.
     * @property z
     * @type {number}
     */
    z: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>2</sub><b>e</b><sub>3</sub> standard basis bivector.
     * @property yz
     * @type {number}
     */
    yz: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>3</sub><b>e</b><sub>1</sub> standard basis bivector.
     * @property zx
     * @type {number}
     */
    zx: number;
    /**
     * The coordinate corresponding to the <b>e</b><sub>1</sub><b>e</b><sub>2</sub> standard basis bivector.
     * @property xy
     * @type {number}
     */
    xy: number;
    /**
     * The coordinate corresponding to the I<sub>3</sub> <code>=</code> <b>e</b><sub>1</sub><b>e</b><sub>2</sub><b>e</b><sub>2</sub> standard basis pseudoscalar.
     * @property xyz
     * @type {number}
     */
    xyz: number;
    /**
     * <p>
     * <code>this ⟼ this + M * α</code>
     * </p>
     * @method add
     * @param M {GeometricE3}
     * @param α [number = 1]
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    add(M: GeometricE3, α?: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ a + b</code>
     * </p>
     * @method add2
     * @param a {GeometricE3}
     * @param b {GeometricE3}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    add2(a: GeometricE3, b: GeometricE3): MutableG3;
    /**
     * @method clone
     * @return {MutableG3} <code>copy(this)</code>
     */
    clone(): MutableG3;
    /**
     * <p>
     * <code>this ⟼ copy(v)</code>
     * </p>
     * @method copy
     * @param M {VectorE3}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    copy(M: GeometricE3): MutableG3;
    /**
     * <p>
     * <code>this ⟼ this / α</code>
     * </p>
     * @method divideByScalar
     * @param α {number}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    divideByScalar(α: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ this + α * (target - this)</code>
     * </p>
     * @method lerp
     * @param target {GeometricE3}
     * @param α {number}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    lerp(target: GeometricE3, α: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ a + α * (b - a)</code>
     * </p>
     * @method lerp2
     * @param a {GeometricE3}
     * @param b {GeometricE3}
     * @param α {number}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    lerp2(a: GeometricE3, b: GeometricE3, α: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ this * α</code>
     * </p>
     * @method scale
     * @param α {number}
     */
    scale(α: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ - n * this * n</code>
     * </p>
     * @method reflect
     * @param n {VectorE3}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    reflect(n: VectorE3): MutableG3;
    /**
     * <p>
     * <code>this ⟼ R * this * reverse(R)</code>
     * </p>
     * @method rotate
     * @param R {SpinorE3}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    rotate(R: SpinorE3): MutableG3;
    /**
     * <p>
     * <code>this ⟼ this - M * α</code>
     * </p>
     * @method sub
     * @param M {GeometricE3}
     * @param α [number = 1]
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    sub(M: GeometricE3, α?: number): MutableG3;
    /**
     * <p>
     * <code>this ⟼ a - b</code>
     * </p>
     * @method sub2
     * @param a {GeometricE3}
     * @param b {GeometricE3}
     * @return {MutableG3} <code>this</code>
     * @chainable
     */
    sub2(a: GeometricE3, b: GeometricE3): MutableG3;
}
export = MutableG3;
