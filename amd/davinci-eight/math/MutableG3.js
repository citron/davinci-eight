var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(["require", "exports", '../checks/mustBeNumber', '../checks/mustBeObject', '../math/VectorN'], function (require, exports, mustBeNumber, mustBeObject, VectorN) {
    // Symbolic constants for the coordinate indices into the data array.
    var COORD_W = 0;
    var COORD_X = 1;
    var COORD_Y = 2;
    var COORD_Z = 3;
    var COORD_YZ = 4;
    var COORD_ZX = 5;
    var COORD_XY = 6;
    var COORD_XYZ = 7;
    /**
     * @class MutableG3
     * @extends GeometricE3
     * @beta
     */
    var MutableG3 = (function (_super) {
        __extends(MutableG3, _super);
        /**
         * Constructs a <code>MutableG3</code> from Cartesian coordinates.
         * The coordinates are provided as an array of 8 <code>number</code>s.
         * The corresponding basis is generated by the standard linear space basis, {<b>e</b><sub>1</sub>, <b>e</b><sub>2</sub>, <b>e</b><sub>3</sub>}.
         * The geometric space basis, ordered to correspond with the coordinates, is
         * [1, <b>e</b><sub>1</sub>, <b>e</b><sub>2</sub>, <b>e</b><sub>3</sub>, <b>e</b><sub>2</sub><b>e</b><sub>3</sub>, <b>e</b><sub>3</sub><b>e</b><sub>1</sub>, <b>e</b><sub>1</sub><b>e</b><sub>2</sub>, <b>e</b><sub>1</sub><b>e</b><sub>2</sub><b>e</b><sub>3</sub>].
         * @class MutableG3
         * @beta
         * @constructor
         * @param data [number[] = [0, 0, 0, 0, 0, 0, 0, 0]] The Cartesian coordinates of the multivector.
         */
        function MutableG3(data) {
            if (data === void 0) { data = [0, 0, 0, 0, 0, 0, 0, 0]; }
            _super.call(this, data, false, 8);
        }
        Object.defineProperty(MutableG3.prototype, "w", {
            /**
             * The coordinate corresponding to the unit standard basis scalar.
             * @property w
             * @type {number}
             */
            get: function () {
                return this.data[COORD_W];
            },
            set: function (w) {
                mustBeNumber('w', w);
                this.modified = this.modified || this.data[COORD_W] !== w;
                this.data[COORD_W] = w;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "x", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>1</sub> standard basis vector.
             * @property x
             * @type {number}
             */
            get: function () {
                return this.data[COORD_X];
            },
            set: function (x) {
                mustBeNumber('x', x);
                this.modified = this.modified || this.data[COORD_X] !== x;
                this.data[COORD_X] = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "y", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>2</sub> standard basis vector.
             * @property y
             * @type {number}
             */
            get: function () {
                return this.data[COORD_Y];
            },
            set: function (y) {
                mustBeNumber('y', y);
                this.modified = this.modified || this.data[COORD_Y] !== y;
                this.data[COORD_Y] = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "z", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>3</sub> standard basis vector.
             * @property z
             * @type {number}
             */
            get: function () {
                return this.data[COORD_Z];
            },
            set: function (z) {
                mustBeNumber('z', z);
                this.modified = this.modified || this.data[COORD_Z] !== z;
                this.data[COORD_Z] = z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "yz", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>2</sub><b>e</b><sub>3</sub> standard basis bivector.
             * @property yz
             * @type {number}
             */
            get: function () {
                return this.data[COORD_YZ];
            },
            set: function (yz) {
                mustBeNumber('yz', yz);
                this.modified = this.modified || this.data[COORD_YZ] !== yz;
                this.data[COORD_YZ] = yz;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "zx", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>3</sub><b>e</b><sub>1</sub> standard basis bivector.
             * @property zx
             * @type {number}
             */
            get: function () {
                return this.data[COORD_ZX];
            },
            set: function (zx) {
                mustBeNumber('zx', zx);
                this.modified = this.modified || this.data[COORD_ZX] !== zx;
                this.data[COORD_ZX] = zx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "xy", {
            /**
             * The coordinate corresponding to the <b>e</b><sub>1</sub><b>e</b><sub>2</sub> standard basis bivector.
             * @property xy
             * @type {number}
             */
            get: function () {
                return this.data[COORD_XY];
            },
            set: function (xy) {
                mustBeNumber('xy', xy);
                this.modified = this.modified || this.data[COORD_XY] !== xy;
                this.data[COORD_XY] = xy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableG3.prototype, "xyz", {
            /**
             * The coordinate corresponding to the I<sub>3</sub> <code>=</code> <b>e</b><sub>1</sub><b>e</b><sub>2</sub><b>e</b><sub>2</sub> standard basis pseudoscalar.
             * @property xyz
             * @type {number}
             */
            get: function () {
                return this.data[COORD_XYZ];
            },
            set: function (xyz) {
                mustBeNumber('xyz', xyz);
                this.modified = this.modified || this.data[COORD_XYZ] !== xyz;
                this.data[COORD_XYZ] = xyz;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * <p>
         * <code>this ⟼ this + M * α</code>
         * </p>
         * @method add
         * @param M {GeometricE3}
         * @param α [number = 1]
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.add = function (M, α) {
            if (α === void 0) { α = 1; }
            mustBeObject('M', M);
            mustBeNumber('α', α);
            this.w += M.w * α;
            this.x += M.x * α;
            this.y += M.y * α;
            this.z += M.z * α;
            this.yz += M.yz * α;
            this.zx += M.zx * α;
            this.xy += M.xy * α;
            this.xyz += M.xyz * α;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ a + b</code>
         * </p>
         * @method add2
         * @param a {GeometricE3}
         * @param b {GeometricE3}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.add2 = function (a, b) {
            mustBeObject('a', a);
            mustBeObject('b', b);
            this.w = a.w + b.w;
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.yz = a.yz + b.yz;
            this.zx = a.zx + b.zx;
            this.xy = a.xy + b.xy;
            this.xyz = a.xyz + b.xyz;
            return this;
        };
        /**
         * @method clone
         * @return {MutableG3} <code>copy(this)</code>
         */
        MutableG3.prototype.clone = function () {
            return new MutableG3([this.w, this.x, this.y, this.z, this.yz, this.zx, this.xy, this.xyz]);
        };
        /**
         * <p>
         * <code>this ⟼ copy(v)</code>
         * </p>
         * @method copy
         * @param M {VectorE3}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.copy = function (M) {
            mustBeObject('M', M);
            this.w = M.w;
            this.x = M.x;
            this.y = M.y;
            this.z = M.z;
            this.yz = M.yz;
            this.zx = M.zx;
            this.xy = M.xy;
            this.xyz = M.xyz;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ this / α</code>
         * </p>
         * @method divideByScalar
         * @param α {number}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.divideByScalar = function (α) {
            mustBeNumber('α', α);
            this.w /= α;
            this.x /= α;
            this.y /= α;
            this.z /= α;
            this.yz /= α;
            this.zx /= α;
            this.xy /= α;
            this.xyz /= α;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ this + α * (target - this)</code>
         * </p>
         * @method lerp
         * @param target {GeometricE3}
         * @param α {number}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.lerp = function (target, α) {
            mustBeObject('target', target);
            mustBeNumber('α', α);
            this.w += (target.w - this.w) * α;
            this.x += (target.x - this.x) * α;
            this.y += (target.y - this.y) * α;
            this.z += (target.z - this.z) * α;
            this.yz += (target.yz - this.yz) * α;
            this.zx += (target.zx - this.zx) * α;
            this.xy += (target.xy - this.xy) * α;
            this.xyz += (target.xyz - this.xyz) * α;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ a + α * (b - a)</code>
         * </p>
         * @method lerp2
         * @param a {GeometricE3}
         * @param b {GeometricE3}
         * @param α {number}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.lerp2 = function (a, b, α) {
            mustBeObject('a', a);
            mustBeObject('b', b);
            mustBeNumber('α', α);
            this.copy(a).lerp(b, α);
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ this * α</code>
         * </p>
         * @method scale
         * @param α {number}
         */
        MutableG3.prototype.scale = function (α) {
            mustBeNumber('α', α);
            this.w *= α;
            this.x *= α;
            this.y *= α;
            this.z *= α;
            this.yz *= α;
            this.zx *= α;
            this.xy *= α;
            this.xyz *= α;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ - n * this * n</code>
         * </p>
         * @method reflect
         * @param n {VectorE3}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.reflect = function (n) {
            // FIXME: This inly reflects the vector components.
            mustBeObject('n', n);
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var nx = n.x;
            var ny = n.y;
            var nz = n.z;
            var dot2 = (x * nx + y * ny + z * nz) * 2;
            this.x = x - dot2 * nx;
            this.y = y - dot2 * ny;
            this.z = z - dot2 * nz;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ R * this * reverse(R)</code>
         * </p>
         * @method rotate
         * @param R {SpinorE3}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.rotate = function (R) {
            mustBeObject('R', R);
            // FIXME: This only rotates the vector components.
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var a = R.xy;
            var b = R.yz;
            var c = R.zx;
            var w = R.w;
            var ix = w * x - c * z + a * y;
            var iy = w * y - a * x + b * z;
            var iz = w * z - b * y + c * x;
            var iw = b * x + c * y + a * z;
            this.x = ix * w + iw * b + iy * a - iz * c;
            this.y = iy * w + iw * c + iz * b - ix * a;
            this.z = iz * w + iw * a + ix * c - iy * b;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ this - M * α</code>
         * </p>
         * @method sub
         * @param M {GeometricE3}
         * @param α [number = 1]
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.sub = function (M, α) {
            if (α === void 0) { α = 1; }
            mustBeObject('M', M);
            mustBeNumber('α', α);
            this.w -= M.w * α;
            this.x -= M.x * α;
            this.y -= M.y * α;
            this.z -= M.z * α;
            this.yz -= M.yz * α;
            this.zx -= M.zx * α;
            this.xy -= M.xy * α;
            this.xyz -= M.xyz * α;
            return this;
        };
        /**
         * <p>
         * <code>this ⟼ a - b</code>
         * </p>
         * @method sub2
         * @param a {GeometricE3}
         * @param b {GeometricE3}
         * @return {MutableG3} <code>this</code>
         * @chainable
         */
        MutableG3.prototype.sub2 = function (a, b) {
            mustBeObject('a', a);
            mustBeObject('b', b);
            this.w = a.w - b.w;
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.yz = a.yz - b.yz;
            this.zx = a.zx - b.zx;
            this.xy = a.xy - b.xy;
            this.xyz = a.xyz - b.xyz;
            return this;
        };
        return MutableG3;
    })(VectorN);
    return MutableG3;
});
