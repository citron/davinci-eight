import MutableGeometricElement = require('../math/MutableGeometricElement');
import Matrix4 = require('../math/Matrix4');
import VectorE3 = require('../math/VectorE3');
declare class MutableQuaternion implements MutableGeometricElement<MutableQuaternion, MutableQuaternion, MutableQuaternion, VectorE3, VectorE3> {
    private x;
    private y;
    private z;
    t: number;
    constructor(t?: number, v?: VectorE3);
    v: VectorE3;
    add(q: MutableQuaternion, α?: number): MutableQuaternion;
    add2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    dual(m: VectorE3): MutableQuaternion;
    clone(): MutableQuaternion;
    conL(rhs: MutableQuaternion): MutableQuaternion;
    conL2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    conR(rhs: MutableQuaternion): MutableQuaternion;
    conR2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    conj(): MutableQuaternion;
    copy(quaternion: MutableQuaternion): MutableQuaternion;
    div(q: MutableQuaternion): MutableQuaternion;
    div2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    divideByScalar(scalar: number): MutableQuaternion;
    dot(v: MutableQuaternion): number;
    exp(): MutableQuaternion;
    inv(): MutableQuaternion;
    lerp(target: MutableQuaternion, α: number): MutableQuaternion;
    lerp2(a: MutableQuaternion, b: MutableQuaternion, α: number): MutableQuaternion;
    log(): MutableQuaternion;
    magnitude(): number;
    mul(q: MutableQuaternion): MutableQuaternion;
    mul2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    norm(): MutableQuaternion;
    scale(α: number): MutableQuaternion;
    normalize(): MutableQuaternion;
    quaditude(): number;
    reflect(n: VectorE3): MutableQuaternion;
    rotate(rotor: MutableQuaternion): MutableQuaternion;
    rotor(a: VectorE3, b: VectorE3): MutableQuaternion;
    rotorFromAxisAngle(axis: VectorE3, θ: number): MutableQuaternion;
    setFromRotationMatrix(m: Matrix4): MutableQuaternion;
    spinor(a: VectorE3, b: VectorE3): MutableQuaternion;
    slerp(qb: MutableQuaternion, t: number): MutableQuaternion;
    align(rhs: MutableQuaternion): MutableQuaternion;
    align2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    sub(q: MutableQuaternion, α?: number): MutableQuaternion;
    sub2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    equals(quaternion: MutableQuaternion): boolean;
    fromArray(array: number[], offset?: number): MutableQuaternion;
    toArray(array?: number[], offset?: number): number[];
    wedge(rhs: MutableQuaternion): MutableQuaternion;
    wedge2(a: MutableQuaternion, b: MutableQuaternion): MutableQuaternion;
    static slerp(qa: MutableQuaternion, qb: MutableQuaternion, qm: MutableQuaternion, t: number): MutableQuaternion;
}
export = MutableQuaternion;
