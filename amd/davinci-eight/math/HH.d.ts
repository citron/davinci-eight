import MutableGeometricElement3D = require('../math/MutableGeometricElement3D');
import Matrix4 = require('../math/Matrix4');
import TrigMethods = require('../math/TrigMethods');
import VectorE3 = require('../math/VectorE3');
declare class HH implements MutableGeometricElement3D<HH, HH, HH, VectorE3, VectorE3>, TrigMethods<HH> {
    private x;
    private y;
    private z;
    t: number;
    constructor(t?: number, v?: VectorE3);
    v: VectorE3;
    add(q: HH, α?: number): HH;
    add2(a: HH, b: HH): HH;
    /**
     * @method arg
     * @return {number}
     */
    arg(): number;
    dual(vector: VectorE3): HH;
    clone(): HH;
    lco(rhs: HH): HH;
    conL2(a: HH, b: HH): HH;
    rco(rhs: HH): HH;
    conR2(a: HH, b: HH): HH;
    conj(): HH;
    copy(quaternion: HH): HH;
    copySpinor(spinor: HH): HH;
    copyVector(vector: VectorE3): HH;
    cos(): HH;
    cosh(): HH;
    div(q: HH): HH;
    div2(a: HH, b: HH): HH;
    divideByScalar(scalar: number): HH;
    dot(v: HH): number;
    exp(): HH;
    inv(): HH;
    lerp(target: HH, α: number): HH;
    lerp2(a: HH, b: HH, α: number): HH;
    log(): HH;
    magnitude(): number;
    mul(q: HH): HH;
    mul2(a: HH, b: HH): HH;
    norm(): HH;
    scale(α: number): HH;
    sin(): HH;
    sinh(): HH;
    neg(): HH;
    normalize(): HH;
    quaditude(): number;
    reflect(n: VectorE3): HH;
    reverse(): HH;
    rotate(rotor: HH): HH;
    rotor(a: VectorE3, b: VectorE3): HH;
    rotorFromAxisAngle(axis: VectorE3, θ: number): HH;
    rotorFromGeneratorAngle(B: HH, θ: number): HH;
    setFromRotationMatrix(m: Matrix4): HH;
    spinor(a: VectorE3, b: VectorE3): HH;
    slerp(qb: HH, t: number): HH;
    align(rhs: HH): HH;
    align2(a: HH, b: HH): HH;
    sub(q: HH, α?: number): HH;
    sub2(a: HH, b: HH): HH;
    equals(quaternion: HH): boolean;
    fromArray(array: number[], offset?: number): HH;
    toArray(array?: number[], offset?: number): number[];
    wedge(rhs: HH): HH;
    wedge2(a: HH, b: HH): HH;
    static slerp(qa: HH, qb: HH, qm: HH, t: number): HH;
}
export = HH;
