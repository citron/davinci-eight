import AttribMetaInfo from '../core/AttribMetaInfo';
import config from '../config';
import getUniformVarName from '../core/getUniformVarName';
import GraphicsProgramSymbols from '../core/GraphicsProgramSymbols';
import mustBeBoolean from '../checks/mustBeBoolean';
import mustBeDefined from '../checks/mustBeDefined';
import UniformMetaInfo from '../core/UniformMetaInfo';

const emitFragmentPrecision = false;
function getUniformCodeName(uniforms: { [name: string]: UniformMetaInfo }, name: string) {
  return getUniformVarName(uniforms[name], name);
}

const SPACE = ' ';
const UNIFORM = 'uniform' + SPACE;
const SEMICOLON = ';';

/**
 * Generates a fragment shader
 */
export default function (attributes: { [name: string]: AttribMetaInfo }, uniforms: { [name: string]: UniformMetaInfo }, vColor: boolean, vCoords: boolean, vLight: boolean) {

  mustBeDefined('attributes', attributes);
  mustBeDefined('uniforms', uniforms);
  mustBeBoolean('vColor', vColor);
  mustBeBoolean('vCoords', vCoords);
  mustBeBoolean('vLight', vLight);

  const lines: string[] = [];
  lines.push(`// fragment shader generated by ${config.NAMESPACE} ${config.VERSION}`);
  // Only the fragment shader requires an explicit precision for floats.
  // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
  // TODO: Make this an option.
  if (emitFragmentPrecision) {
    lines.push("#ifdef GL_ES");
    lines.push("#  ifdef GL_FRAGMENT_PRECISION_HIGH");
    lines.push("precision highp float;");
    lines.push("#  else");
    lines.push("precision mediump float;");
    lines.push("#  endif");
    lines.push("#endif");
  }
  if (vColor) {
    lines.push("varying highp vec4 vColor;");
  }
  if (vCoords) {
    lines.push("varying highp vec2 vCoords;");
  }
  if (vLight) {
    lines.push("varying highp vec3 vLight;");
  }
  for (let uName in uniforms) {
    if (uniforms.hasOwnProperty(uName)) {
      switch (uniforms[uName].glslType) {
        case 'sampler2D': {
          lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
          break;
        }
        default: {
          // Do nothing.
        }
      }
    }
  }

  lines.push("void main(void) {");
  if (vLight) {
    if (vColor) {
      if (vCoords && uniforms[GraphicsProgramSymbols.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GraphicsProgramSymbols.UNIFORM_IMAGE}, vCoords) * vec4(vColor.xyz * vLight, vColor.a);`);
      }
      else {
        lines.push("  gl_FragColor = vec4(vColor.xyz * vLight, vColor.a);");
      }
    }
    else {
      lines.push("  gl_FragColor = vec4(vLight, 1.0);");
    }
  }
  else {
    if (vColor) {
      if (vCoords && uniforms[GraphicsProgramSymbols.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GraphicsProgramSymbols.UNIFORM_IMAGE}, vCoords) * vColor;`);
      }
      else {
        lines.push("  gl_FragColor = vColor;");
      }
    }
    else {
      if (vCoords && uniforms[GraphicsProgramSymbols.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GraphicsProgramSymbols.UNIFORM_IMAGE}, vCoords);`);
      }
      else {
        lines.push("  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
      }
    }
  }
  lines.push("}");
  lines.push("");
  const code = lines.join("\n");
  return code;
}
