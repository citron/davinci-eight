import AttribMetaInfo from '../core/AttribMetaInfo';
import mustBeBoolean from '../checks/mustBeBoolean';
import mustBeDefined from '../checks/mustBeDefined';
import UniformMetaInfo from '../core/UniformMetaInfo';

/**
 * Generates a fragment shader
 */
export default function fragmentShader(attributes: { [name: string]: AttribMetaInfo }, uniforms: { [name: string]: UniformMetaInfo }, vColor: boolean, vLight: boolean) {

    mustBeDefined('attributes', attributes);
    mustBeDefined('uniforms', uniforms);
    mustBeBoolean('vColor', vColor);
    mustBeBoolean('vLight', vLight);

    var lines: string[] = [];
    lines.push("// fragment shader generated by EIGHT")
    // Only the fragment shader requires an explicit precision for floats.
    // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
    // TODO: Make this an option.
    if (false) {
        lines.push("#ifdef GL_ES")
        lines.push("#  ifdef GL_FRAGMENT_PRECISION_HIGH")
        lines.push("precision highp float;")
        lines.push("#  else")
        lines.push("precision mediump float;")
        lines.push("#  endif")
        lines.push("#endif")
    }
    if (vColor) {
        lines.push("varying highp vec4 vColor;");
    }
    if (vLight) {
        lines.push("varying highp vec3 vLight;");
    }
    lines.push("void main(void) {");
    let glFragColor: string[] = [];
    if (vLight) {
        if (vColor) {
            lines.push("  gl_FragColor = vec4(vColor.xyz * vLight, vColor.a);");
        }
        else {
            lines.push("  gl_FragColor = vec4(vLight, 1.0);");
        }
    }
    else {
        if (vColor) {
            lines.push("  gl_FragColor = vColor;");
        }
        else {
            lines.push("  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
        }
    }
    lines.push("}");
    var code = lines.join("\n");
    return code;
}
