/// <reference path="../vendor/davinci-blade/dist/davinci-blade.d.ts" />
import DataUsage = require('davinci-eight/core/DataUsage');
import DrawMode = require('davinci-eight/core/DrawMode');
import UniformMetaInfos = require('davinci-eight/core/UniformMetaInfos');
import AttributeProvider = require('davinci-eight/core/AttributeProvider');
import AttributeMetaInfos = require('davinci-eight/core/AttributeMetaInfos');
import Node3D = require('davinci-eight/core/Node3D');
import Color = require('davinci-eight/core/Color');
import View = require('davinci-eight/cameras/View');
import Frustum = require('davinci-eight/cameras/Frustum');
import LinearPerspectiveCamera = require('davinci-eight/cameras/LinearPerspectiveCamera');
import DrawList = require('davinci-eight/drawLists/DrawList');
import UniformProvider = require('davinci-eight/core/UniformProvider');
import Face3 = require('davinci-eight/core/Face3');
import ShaderAttributeLocation = require('davinci-eight/core/ShaderAttributeLocation');
import ShaderUniformLocation = require('davinci-eight/core/ShaderUniformLocation');
import Geometry = require('davinci-eight/geometries/Geometry');
import GeometryAdapter = require('davinci-eight/geometries/GeometryAdapter');
import ArrowGeometry = require('davinci-eight/geometries/ArrowGeometry');
import BoxGeometry = require('davinci-eight/geometries/BoxGeometry');
import CylinderGeometry = require('davinci-eight/geometries/CylinderGeometry');
import DodecahedronGeometry = require('davinci-eight/geometries/DodecahedronGeometry');
import IcosahedronGeometry = require('davinci-eight/geometries/IcosahedronGeometry');
import KleinBottleGeometry = require('davinci-eight/geometries/KleinBottleGeometry');
import MobiusStripGeometry = require('davinci-eight/geometries/MobiusStripGeometry');
import OctahedronGeometry = require('davinci-eight/geometries/OctahedronGeometry');
import ParametricGeometry = require('davinci-eight/geometries/ParametricGeometry');
import PolyhedronGeometry = require('davinci-eight/geometries/PolyhedronGeometry');
import RevolutionGeometry = require('davinci-eight/geometries/RevolutionGeometry');
import SphereGeometry = require('davinci-eight/geometries/SphereGeometry');
import TetrahedronGeometry = require('davinci-eight/geometries/TetrahedronGeometry');
import TubeGeometry = require('davinci-eight/geometries/TubeGeometry');
import VortexGeometry = require('davinci-eight/geometries/VortexGeometry');
import Matrix3 = require('davinci-eight/math/Matrix3');
import Matrix4 = require('davinci-eight/math/Matrix4');
import Spinor3 = require('davinci-eight/math/Spinor3');
import Vector2 = require('davinci-eight/math/Vector2');
import Vector3 = require('davinci-eight/math/Vector3');
import ArrowBuilder = require('davinci-eight/mesh/ArrowBuilder');
import ArrowOptions = require('davinci-eight/mesh/ArrowOptions');
import BoxBuilder = require('davinci-eight/mesh/BoxBuilder');
import BoxOptions = require('davinci-eight/mesh/BoxOptions');
import SphereBuilder = require('davinci-eight/mesh/SphereBuilder');
import SphereOptions = require('davinci-eight/mesh/SphereOptions');
import DrawableModel = require('davinci-eight/objects/DrawableModel');
import Curve = require('davinci-eight/curves/Curve');
import ShaderProgram = require('davinci-eight/programs/ShaderProgram');
import Renderer = require('davinci-eight/renderers/Renderer');
import RendererParameters = require('davinci-eight/renderers/RendererParameters');
import WebGLRenderer = require('davinci-eight/renderers/WebGLRenderer');
import Viewport = require('davinci-eight/renderers/Viewport');
import ViewportParameters = require('davinci-eight/renderers/ViewportParameters');
import AmbientLight = require('davinci-eight/uniforms/AmbientLight');
import ChainedUniformProvider = require('davinci-eight/uniforms/ChainedUniformProvider');
import DefaultUniformProvider = require('davinci-eight/uniforms/DefaultUniformProvider');
import DirectionalLight = require('davinci-eight/uniforms/DirectionalLight');
import LocalModel = require('davinci-eight/uniforms/LocalModel');
import Node = require('davinci-eight/uniforms/Node');
import TreeModel = require('davinci-eight/uniforms/TreeModel');
import UniversalJoint = require('davinci-eight/uniforms/UniversalJoint');
import MultiUniformProvider = require('davinci-eight/uniforms/MultiUniformProvider');
import PointLight = require('davinci-eight/uniforms/PointLight');
import UniformFloat = require('davinci-eight/uniforms/UniformFloat');
import UniformMat4 = require('davinci-eight/uniforms/UniformMat4');
import UniformVec2 = require('davinci-eight/uniforms/UniformVec2');
import UniformVec3 = require('davinci-eight/uniforms/UniformVec3');
import UniformVec4 = require('davinci-eight/uniforms/UniformVec4');
import UniformVector3 = require('davinci-eight/uniforms/UniformVector3');
import UniformSpinor3 = require('davinci-eight/uniforms/UniformSpinor3');
import RenderingContextMonitor = require('davinci-eight/utils/RenderingContextMonitor');
import WindowAnimationRunner = require('davinci-eight/utils/WindowAnimationRunner');
/**
 * @module d8
 */
declare var eight: {
    'VERSION': string;
    initWebGL: (canvas: HTMLCanvasElement, attributes: {
        alpha?: boolean;
        antialias?: boolean;
        depth?: boolean;
        premultipliedAlpha?: boolean;
        preserveDrawingBuffer?: boolean;
        stencil?: boolean;
    }) => WebGLRenderingContext;
    view: (options?: {
        viewMatrixName?: string;
    }) => View;
    frustum: (left?: number, right?: number, bottom?: number, top?: number, near?: number, far?: number) => Frustum;
    perspective: (options?: {
        fov?: number;
        aspect?: number;
        near?: number;
        far?: number;
        projectionMatrixName?: string;
        viewMatrixName?: string;
    }) => LinearPerspectiveCamera;
    drawList: () => DrawList;
    object3D: () => Node3D;
    renderer: (canvas: HTMLCanvasElement, parameters?: RendererParameters) => Renderer;
    viewport: (canvas: HTMLCanvasElement, parameters: ViewportParameters) => Viewport;
    webGLRenderer: (canvas: HTMLCanvasElement) => WebGLRenderer;
    contextMonitor: (canvas: HTMLCanvasElement, attributes?: {
        alpha?: boolean;
        antialias?: boolean;
        depth?: boolean;
        premultipliedAlpha?: boolean;
        preserveDrawingBuffer?: boolean;
        stencil?: boolean;
    }) => RenderingContextMonitor;
    workbench: (canvas: HTMLCanvasElement, renderer: any, camera: {
        aspect: number;
    }, win?: Window) => {
        setUp: () => void;
        tearDown: () => void;
    };
    animation: (animate: (time: number) => void, options?: {
        setUp?: () => void;
        tearDown?: (animateException: any) => void;
        terminate?: (time: number) => boolean;
        window?: Window;
    }) => WindowAnimationRunner;
    DataUsage: typeof DataUsage;
    drawableModel: <MESH extends AttributeProvider, SHADERS extends ShaderProgram, MODEL extends UniformProvider>(mesh: MESH, shaders: SHADERS, model: MODEL) => DrawableModel<MESH, SHADERS, MODEL>;
    DrawMode: typeof DrawMode;
    ShaderAttributeLocation: typeof ShaderAttributeLocation;
    ShaderUniformLocation: typeof ShaderUniformLocation;
    pointsProgram: () => ShaderProgram;
    shaderProgram: (vertexShader: string, fragmentShader: string) => ShaderProgram;
    smartProgram: (attributes: AttributeMetaInfos, uniformsList: UniformMetaInfos[]) => ShaderProgram;
    AmbientLight: typeof AmbientLight;
    DirectionalLight: typeof DirectionalLight;
    PointLight: typeof PointLight;
    Color: typeof Color;
    Face3: typeof Face3;
    Geometry: typeof Geometry;
    GeometryAdapter: typeof GeometryAdapter;
    ArrowGeometry: typeof ArrowGeometry;
    BoxGeometry: typeof BoxGeometry;
    CylinderGeometry: typeof CylinderGeometry;
    DodecahedronGeometry: typeof DodecahedronGeometry;
    IcosahedronGeometry: typeof IcosahedronGeometry;
    KleinBottleGeometry: typeof KleinBottleGeometry;
    MobiusStripGeometry: typeof MobiusStripGeometry;
    OctahedronGeometry: typeof OctahedronGeometry;
    ParametricGeometry: typeof ParametricGeometry;
    PolyhedronGeometry: typeof PolyhedronGeometry;
    RevolutionGeometry: typeof RevolutionGeometry;
    SphereGeometry: typeof SphereGeometry;
    TetrahedronGeometry: typeof TetrahedronGeometry;
    TubeGeometry: typeof TubeGeometry;
    VortexGeometry: typeof VortexGeometry;
    LocalModel: typeof LocalModel;
    Node: typeof Node;
    TreeModel: typeof TreeModel;
    UniversalJoint: typeof UniversalJoint;
    UniformFloat: typeof UniformFloat;
    UniformMat4: typeof UniformMat4;
    UniformVec2: typeof UniformVec2;
    UniformVec3: typeof UniformVec3;
    UniformVec4: typeof UniformVec4;
    UniformVector3: typeof UniformVector3;
    UniformSpinor3: typeof UniformSpinor3;
    Matrix3: typeof Matrix3;
    Matrix4: typeof Matrix4;
    Spinor3: typeof Spinor3;
    Vector2: typeof Vector2;
    Vector3: typeof Vector3;
    Curve: typeof Curve;
    ChainedUniformProvider: typeof ChainedUniformProvider;
    DefaultUniformProvider: typeof DefaultUniformProvider;
    MultiUniformProvider: typeof MultiUniformProvider;
    uniforms: (providers: UniformProvider[]) => UniformProvider;
    arrowMesh: (options?: ArrowOptions) => AttributeProvider;
    ArrowBuilder: typeof ArrowBuilder;
    boxMesh: (options?: BoxOptions) => AttributeProvider;
    BoxBuilder: typeof BoxBuilder;
    cylinderMesh: (options?: {
        wireFrame?: boolean;
    }) => AttributeProvider;
    sphereMesh: (options?: SphereOptions) => AttributeProvider;
    vortexMesh: (options?: {
        wireFrame?: boolean;
    }) => AttributeProvider;
    arrow: (ambients: UniformProvider, options?: ArrowOptions) => DrawableModel<AttributeProvider, ShaderProgram, Node>;
    box: (ambients: UniformProvider, options?: BoxOptions) => DrawableModel<AttributeProvider, ShaderProgram, Node>;
    cylinder: (ambients: UniformProvider) => DrawableModel<AttributeProvider, ShaderProgram, Node>;
    sphere: (ambients: UniformProvider, options?: SphereOptions) => DrawableModel<AttributeProvider, ShaderProgram, Node>;
    SphereBuilder: typeof SphereBuilder;
    vortex: (ambients: UniformProvider) => DrawableModel<AttributeProvider, ShaderProgram, Node>;
    shaderProgramFromScripts: (vsId: string, fsId: string, $document?: Document) => ShaderProgram;
};
export = eight;
